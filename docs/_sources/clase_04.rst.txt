.. _clase_04:

Clase 4: Iteraciones y detalles de Funciones
=============================================


Técnicas de iteración
---------------------

Introdujimos tipos complejos: strings, listas, tuples, diccionarios
(``dict``), conjuntos (``set``). Veamos algunas técnicas usuales de
iteración sobre estos objetos.

Iteración sobre elementos de dos listas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consideremos las listas:

.. code:: python

    temp_min = [-3.2, -2, 0, -1, 4, -5, -2, 0, 4, 0]
    temp_max = [13.2, 12, 13, 7, 18, 5, 11, 14, 10 , 10]

Queremos imprimir una lista que combine los dos datos:

.. code:: python

    for t1, t2 in zip(temp_min, temp_max):
      print(f"La temperatura mínima fue {t1} y la máxima fue {t2}")


.. parsed-literal::

    La temperatura mínima fue -3.2 y la máxima fue 13.2
    La temperatura mínima fue -2 y la máxima fue 12
    La temperatura mínima fue 0 y la máxima fue 13
    La temperatura mínima fue -1 y la máxima fue 7
    La temperatura mínima fue 4 y la máxima fue 18
    La temperatura mínima fue -5 y la máxima fue 5
    La temperatura mínima fue -2 y la máxima fue 11
    La temperatura mínima fue 0 y la máxima fue 14
    La temperatura mínima fue 4 y la máxima fue 10
    La temperatura mínima fue 0 y la máxima fue 10


Como vemos, la función ``zip`` nos permite combinar los elementos,
tomando uno de cada lista por iteración.

¿Qué retorna exactamente \`zip``?

.. code:: python

    print(zip(temp_min, temp_max))
    list(zip(temp_min, temp_max))


.. parsed-literal::

    <zip object at 0x7f0c96b02240>




.. parsed-literal::

    [(-3.2, 13.2),
     (-2, 12),
     (0, 13),
     (-1, 7),
     (4, 18),
     (-5, 5),
     (-2, 11),
     (0, 14),
     (4, 10),
     (0, 10)]



Podemos agregar información del día en la salida por pantalla si
volvemos a utilizar la función ``enumerate``

.. code:: python

    for j, t in enumerate(zip(temp_min, temp_max)):
      print(f'El día {j+1} la temperatura mínima fue {t[0]} y la máxima fue {t[1]}')


.. parsed-literal::

    El día 1 la temperatura mínima fue -3.2 y la máxima fue 13.2
    El día 2 la temperatura mínima fue -2 y la máxima fue 12
    El día 3 la temperatura mínima fue 0 y la máxima fue 13
    El día 4 la temperatura mínima fue -1 y la máxima fue 7
    El día 5 la temperatura mínima fue 4 y la máxima fue 18
    El día 6 la temperatura mínima fue -5 y la máxima fue 5
    El día 7 la temperatura mínima fue -2 y la máxima fue 11
    El día 8 la temperatura mínima fue 0 y la máxima fue 14
    El día 9 la temperatura mínima fue 4 y la máxima fue 10
    El día 10 la temperatura mínima fue 0 y la máxima fue 10


.. code:: python

    for j, (t1,t2) in enumerate(zip(temp_min, temp_max),1):
      print(f'El día {j} la temperatura mínima fue {t1} y la máxima fue {t2}')



.. parsed-literal::

    El día 1 la temperatura mínima fue -3.2 y la máxima fue 13.2
    El día 2 la temperatura mínima fue -2 y la máxima fue 12
    El día 3 la temperatura mínima fue 0 y la máxima fue 13
    El día 4 la temperatura mínima fue -1 y la máxima fue 7
    El día 5 la temperatura mínima fue 4 y la máxima fue 18
    El día 6 la temperatura mínima fue -5 y la máxima fue 5
    El día 7 la temperatura mínima fue -2 y la máxima fue 11
    El día 8 la temperatura mínima fue 0 y la máxima fue 14
    El día 9 la temperatura mínima fue 4 y la máxima fue 10
    El día 10 la temperatura mínima fue 0 y la máxima fue 10


.. code:: python

    # ¿Qué pasa cuando una se consume antes que la otra?
    for t1, t2 in zip([1,2,3,4,5],[3,4,5]):
        print(t1,t2)


.. parsed-literal::

    1 3
    2 4
    3 5


``zip`` funciona también con más de dos listas

.. code:: python

    for j,t1,t2 in zip(range(1,len(temp_min)+1),temp_min, temp_max):
      print(f'El día {j} la temperatura mínima fue {t1} y la máxima fue {t2}')



.. parsed-literal::

    El día 1 la temperatura mínima fue -3.2 y la máxima fue 13.2
    El día 2 la temperatura mínima fue -2 y la máxima fue 12
    El día 3 la temperatura mínima fue 0 y la máxima fue 13
    El día 4 la temperatura mínima fue -1 y la máxima fue 7
    El día 5 la temperatura mínima fue 4 y la máxima fue 18
    El día 6 la temperatura mínima fue -5 y la máxima fue 5
    El día 7 la temperatura mínima fue -2 y la máxima fue 11
    El día 8 la temperatura mínima fue 0 y la máxima fue 14
    El día 9 la temperatura mínima fue 4 y la máxima fue 10
    El día 10 la temperatura mínima fue 0 y la máxima fue 10


Podemos utilizar la función ``zip`` para sumar dos listas término a
término

.. code:: python

    tmedia = []
    for t1, t2 in zip(temp_min, temp_max):
      tmedia.append((t1+t2)/2)
    print(tmedia)


.. parsed-literal::

    [5.0, 5.0, 6.5, 3.0, 11.0, 0.0, 4.5, 7.0, 7.0, 5.0]


También podemos escribirlo en forma más compacta usando comprensiones de
listas

.. code:: python

    tm = [(t1+t2)/2 for t1,t2 in zip(temp_min,temp_max)]
    print(tm)


.. parsed-literal::

    [5.0, 5.0, 6.5, 3.0, 11.0, 0.0, 4.5, 7.0, 7.0, 5.0]


Iteraciones sobre diccionarios
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    # temps = {j:{"Tmin": temp_min[j], "Tmax":temp_max[j]} for j in range(len(temp_min))}
    temps = {j:{"Tmin": tmin, "Tmax":tmax} for j,(tmin,tmax) in enumerate(zip(temp_min, temp_max))}

.. code:: python

    temps




.. parsed-literal::

    {0: {'Tmin': -3.2, 'Tmax': 13.2},
     1: {'Tmin': -2, 'Tmax': 12},
     2: {'Tmin': 0, 'Tmax': 13},
     3: {'Tmin': -1, 'Tmax': 7},
     4: {'Tmin': 4, 'Tmax': 18},
     5: {'Tmin': -5, 'Tmax': 5},
     6: {'Tmin': -2, 'Tmax': 11},
     7: {'Tmin': 0, 'Tmax': 14},
     8: {'Tmin': 4, 'Tmax': 10},
     9: {'Tmin': 0, 'Tmax': 10}}



.. code:: python

    for k in temps:
      print(f'La temperatura máxima del día {k} fue {temps[k]["Tmax"]} y la mínima {temps[k]["Tmin"]}')


.. parsed-literal::

    La temperatura máxima del día 0 fue 13.2 y la mínima -3.2
    La temperatura máxima del día 1 fue 12 y la mínima -2
    La temperatura máxima del día 2 fue 13 y la mínima 0
    La temperatura máxima del día 3 fue 7 y la mínima -1
    La temperatura máxima del día 4 fue 18 y la mínima 4
    La temperatura máxima del día 5 fue 5 y la mínima -5
    La temperatura máxima del día 6 fue 11 y la mínima -2
    La temperatura máxima del día 7 fue 14 y la mínima 0
    La temperatura máxima del día 8 fue 10 y la mínima 4
    La temperatura máxima del día 9 fue 10 y la mínima 0


Como comentamos anteriormente, cuando iteramos sobre un diccionario
estamos moviéndonos sobre las ``(k)eys``. El ejemplo anterior es
equivalente a:

.. code:: python

    for k in temps.keys():
      print(f'La temperatura máxima del día {k} fue {temps[k]["Tmax"]} y la mínima {temps[k]["Tmin"]}')


.. parsed-literal::

    La temperatura máxima del día 0 fue 13.2 y la mínima -3.2
    La temperatura máxima del día 1 fue 12 y la mínima -2
    La temperatura máxima del día 2 fue 13 y la mínima 0
    La temperatura máxima del día 3 fue 7 y la mínima -1
    La temperatura máxima del día 4 fue 18 y la mínima 4
    La temperatura máxima del día 5 fue 5 y la mínima -5
    La temperatura máxima del día 6 fue 11 y la mínima -2
    La temperatura máxima del día 7 fue 14 y la mínima 0
    La temperatura máxima del día 8 fue 10 y la mínima 4
    La temperatura máxima del día 9 fue 10 y la mínima 0


En este caso, para referirnos al valor tenemos que hacerlo en la forma
``temps[k]``, y no siempre es una manera muy clara de escribir las
cosas. Otra manera similar, pero más limpia en este caso sería:

.. code:: python

    for k, v in temps.items():
      print(f"La temperatura máxima del día {k} fue {v['Tmin']} y la mínima {v['Tmax']}")


.. parsed-literal::

    La temperatura máxima del día 0 fue -3.2 y la mínima 13.2
    La temperatura máxima del día 1 fue -2 y la mínima 12
    La temperatura máxima del día 2 fue 0 y la mínima 13
    La temperatura máxima del día 3 fue -1 y la mínima 7
    La temperatura máxima del día 4 fue 4 y la mínima 18
    La temperatura máxima del día 5 fue -5 y la mínima 5
    La temperatura máxima del día 6 fue -2 y la mínima 11
    La temperatura máxima del día 7 fue 0 y la mínima 14
    La temperatura máxima del día 8 fue 4 y la mínima 10
    La temperatura máxima del día 9 fue 0 y la mínima 10


Si queremos iterar sobre los valores podemos utilizar simplemente:

.. code:: python

    for v in temps.values():
      print(v)


.. parsed-literal::

    {'Tmin': -3.2, 'Tmax': 13.2}
    {'Tmin': -2, 'Tmax': 12}
    {'Tmin': 0, 'Tmax': 13}
    {'Tmin': -1, 'Tmax': 7}
    {'Tmin': 4, 'Tmax': 18}
    {'Tmin': -5, 'Tmax': 5}
    {'Tmin': -2, 'Tmax': 11}
    {'Tmin': 0, 'Tmax': 14}
    {'Tmin': 4, 'Tmax': 10}
    {'Tmin': 0, 'Tmax': 10}


Remarquemos que los diccionarios no tienen definidos un orden por lo que
no hay garantías que la próxima vez que ejecutemos cualquiera de estas
líneas de código el orden del resultado sea exactamente el mismo.
Además, si queremos imprimirlos en un orden predecible debemos
escribirlo explícitamente. Por ejemplo:

.. code:: python

    L = list(temps.keys())
    L.sort(reverse=True)
    for k in L:
      print(k, temps[k])


.. parsed-literal::

    9 {'Tmin': 0, 'Tmax': 10}
    8 {'Tmin': 4, 'Tmax': 10}
    7 {'Tmin': 0, 'Tmax': 14}
    6 {'Tmin': -2, 'Tmax': 11}
    5 {'Tmin': -5, 'Tmax': 5}
    4 {'Tmin': 4, 'Tmax': 18}
    3 {'Tmin': -1, 'Tmax': 7}
    2 {'Tmin': 0, 'Tmax': 13}
    1 {'Tmin': -2, 'Tmax': 12}
    0 {'Tmin': -3.2, 'Tmax': 13.2}


La secuencia anterior puede escribirse en forma más compacta como

.. code:: python

    for k in sorted(temps,reverse=True):
      print(k, temps[k])


.. parsed-literal::

    9 {'Tmin': 0, 'Tmax': 10}
    8 {'Tmin': 4, 'Tmax': 10}
    7 {'Tmin': 0, 'Tmax': 14}
    6 {'Tmin': -2, 'Tmax': 11}
    5 {'Tmin': -5, 'Tmax': 5}
    4 {'Tmin': 4, 'Tmax': 18}
    3 {'Tmin': -1, 'Tmax': 7}
    2 {'Tmin': 0, 'Tmax': 13}
    1 {'Tmin': -2, 'Tmax': 12}
    0 {'Tmin': -3.2, 'Tmax': 13.2}


--------------

Ejercicios 04 (a)
-----------------

1. Un método para calcular el área de un polígono (no necesariamente
   regular) que se conoce como fórmula del área de Gauss o fórmula de la
   Lazada (*shoelace formula*) consiste en describir al polígono por sus
   puntos en un sistema de coordenadas. Cada punto se describe como un
   par :math:`(x,y)` y la fórmula del área está dada mediante la suma de
   la multiplicación de los valores en una diagonal a los que se le
   resta los valores en la otra diagonal, como muestra la figura

   .. image:: figuras/shoelace.png

   .. math::  2 A = (x_{1} y_{2} + x_{2} y_{3} + x_{3} y_{4} + \dots) - (x_{2} y_{1} + x_{3} y_{2} + x_{4} y_{3} + \dots) 

   .. image:: figuras/ejemplo_shoelace.png

   -  Utilizando una descripción adecuada del polígono, escribir una
      función que implemente la fórmula de Gauss para calcular su área y
      aplicarla al ejemplo de la figura.

   -  Verificar que el resultado no depende del punto de inicio.

--------------

.


Argumentos de las funciones
---------------------------

Ámbito de las variables en los argumentos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consideremos la siguiente función

.. code:: python

    sep = 47*'-'
    def func1(x):
      print(sep,'\nx entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x = 2
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x),'\n', sep)

.. code:: python

    x = 50
    print('Id afuera antes:',id(x))
    print('Fuera de la función: Originalmente x vale',x)
    func1(x)
    print('Fuera de la función: Ahora x vale',x)  
    print('Id afuera después:',id(x))


.. parsed-literal::

    Id afuera antes: 140188951942440
    Fuera de la función: Originalmente x vale 50
    ----------------------------------------------- 
    x entró a la función con el valor 50
    Id adentro: 140188951942440
    El nuevo valor de x es 2
    Id adentro nuevo: 140188951940904 
     -----------------------------------------------
    Fuera de la función: Ahora x vale 50
    Id afuera después: 140188951942440


Vemos que la variable ``x`` que utilizamos como argumento de la función
debe ser diferente a la variable ``x`` que se define fuera de la
función, ya que su valor no cambia al salir. Además usamos la función
``id()`` para obtener la identidad de la variable y vemos que

Consideremos ahora la siguiente función:

.. code:: python

    def func2(x):
      print(sep,'\nx entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x = [2,7]
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x),'\n', sep)

La función es muy parecida, sólo que le estamos dando a la variable
``x`` dentro de la función un nuevo valor del tipo ``lista``.

.. code:: python

    x = 50
    print('Id afuera antes:',id(x))
    print('Fuera de la función: Originalmente x vale',x)
    func2(x)
    print('Fuera de la función: Ahora x vale',x)  
    print('Id afuera después:',id(x))


.. parsed-literal::

    Id afuera antes: 140188951942440
    Fuera de la función: Originalmente x vale 50
    ----------------------------------------------- 
    x entró a la función con el valor 50
    Id adentro: 140188951942440
    El nuevo valor de x es [2, 7]
    Id adentro nuevo: 140188621633792 
     -----------------------------------------------
    Fuera de la función: Ahora x vale 50
    Id afuera después: 140188951942440


.. code:: python

    x = [50]
    print('Id afuera antes:',id(x))
    print('Fuera de la función: Originalmente x vale',x)
    func2(x)
    print('Fuera de la función: Ahora x vale',x)  
    print('Id afuera después:',id(x))


.. parsed-literal::

    Id afuera antes: 140188662789248
    Fuera de la función: Originalmente x vale [50]
    ----------------------------------------------- 
    x entró a la función con el valor [50]
    Id adentro: 140188662789248
    El nuevo valor de x es [2, 7]
    Id adentro nuevo: 140188621702208 
     -----------------------------------------------
    Fuera de la función: Ahora x vale [50]
    Id afuera después: 140188662789248


¿Qué está pasando acá?

-  Cuando se realiza la llamada a la función, se le pasa una copia del
   nombre ``x``.
-  Cuando le damos un nuevo valor dentro de la función, como en el caso
   ``x = [2, 7]``, entonces se crea una nueva variable y el nombre ``x``
   queda asociado a la nueva variable.
-  La variable original –definida fuera de la función– no cambia.

En el primer caso, como los escalares son inmutables (de la misma manera
que los strings y tuplas) no puede ser modificada. Al reasignar el
nombre siempre se crea una nueva variable (para cualquier tipo).

Consideremos estas variantes, donde el comportamiento entre tipos
mutables e inmutables son diferentes:

.. code:: python

    def func3(x):
      print(sep,'\nx entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x += [2,7]
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x),'\n', sep)

.. code:: python

    x = [50]
    print('Id afuera antes:',id(x))
    print('Fuera de la función: Originalmente x vale',x)
    func3(x)
    print('Fuera de la función: Ahora x vale',x)  
    print('Id afuera después:',id(x))


.. parsed-literal::

    Id afuera antes: 140188610229760
    Fuera de la función: Originalmente x vale [50]
    ----------------------------------------------- 
    x entró a la función con el valor [50]
    Id adentro: 140188610229760
    El nuevo valor de x es [50, 2, 7]
    Id adentro nuevo: 140188610229760 
     -----------------------------------------------
    Fuera de la función: Ahora x vale [50, 2, 7]
    Id afuera después: 140188610229760


En este caso, como no estamos redefiniendo la variable sino que la
estamos modificando, el nuevo valor se mantiene al terminar la ejecución
de la función. Otra variante:

.. code:: python

    def func4(x):
      print(sep,'\nx entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x[0] = 2
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x),'\n', sep)

.. code:: python

    x = [50]
    print('Id afuera antes:',id(x))
    print('Fuera de la función: Originalmente x vale',x)
    func4(x)
    print('Fuera de la función: Ahora x vale',x)  
    print('Id afuera después:',id(x))


.. parsed-literal::

    Id afuera antes: 140188663004160
    Fuera de la función: Originalmente x vale [50]
    ----------------------------------------------- 
    x entró a la función con el valor [50]
    Id adentro: 140188663004160
    El nuevo valor de x es [2]
    Id adentro nuevo: 140188663004160 
     -----------------------------------------------
    Fuera de la función: Ahora x vale [2]
    Id afuera después: 140188663004160


Vemos que, cuando modificamos la variable (solo es posible para tipos
mutables), asignando un valor a uno o más de sus elementos o
agregando/removiendo elementos, la copia sigue apuntando a la variable
original y el valor de la variable, definida originalmente afuera,
cambia.

Funciones con argumentos opcionales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Las funciones pueden tener muchos argumentos. En **Python** pueden tener
un número variable de argumentos y pueden tener valores por *default*
para algunos de ellos. En el caso de la función de caída libre, vamos a
extenderlo de manera que podamos usarlo fuera de la tierra (o en otras
latitudes) permitiendo cambiar el valor de la gravedad y asumiendo que,
a menos que lo pidamos explícitamente se trata de una simple caída
libre:

.. code:: python

    def caida_libre(t, h0, v0=0., g=9.8):
      """Devuelve la velocidad y la posición de una partícula en
      caída libre para condiciones iniciales dadas
    
      Parameters
      ----------
      t : float
          el tiempo al que queremos realizar el cálculo
      h0: float 
          la altura inicial
      v0: float (opcional)
          la velocidad inicial (default = 0.0)
       g: float (opcional)
          valor de la aceleración de la gravedad (default = 9.8)
    
      Returns
      -------
      (v,h):  tuple of floats
           v= v0 - g*t
           h= h0 - v0*t -g*t^2/2
      
      """
      v = v0 - g*t
      h = h0 - v0*t - g*t**2/2.
      return v,h


.. code:: python

    # Desde 1000 metros con velocidad inicial cero
    print( caida_libre(2,1000))


.. parsed-literal::

    (-19.6, 980.4)


.. code:: python

    # Desde 1000 metros con velocidad inicial hacia arriba
    print(caida_libre(1, 1000, 10))


.. parsed-literal::

    (0.1999999999999993, 985.1)


.. code:: python

    # Desde 1000 metros con velocidad inicial cero
    print(caida_libre(h0=1000, t=2))


.. parsed-literal::

    (-19.6, 980.4)


.. code:: python

    # Desde 1000 metros con velocidad inicial cero en la luna
    print( caida_libre( v0=0, h0=1000, t=14.2857137, g=1.625))


.. parsed-literal::

    (-23.2142847625, 834.1836870663262)


.. code:: python

    print( caida_libre(3, 1000, g=1.625))


.. parsed-literal::

    (-4.875, 992.6875)


.. code:: python

    help(caida_libre)


.. parsed-literal::

    Help on function caida_libre in module __main__:
    
    caida_libre(t, h0, v0=0.0, g=9.8)
        Devuelve la velocidad y la posición de una partícula en
        caída libre para condiciones iniciales dadas
        
        Parameters
        ----------
        t : float
            el tiempo al que queremos realizar el cálculo
        h0: float 
            la altura inicial
        v0: float (opcional)
            la velocidad inicial (default = 0.0)
         g: float (opcional)
            valor de la aceleración de la gravedad (default = 9.8)
        
        Returns
        -------
        (v,h):  tuple of floats
             v= v0 - g*t
             h= h0 - v0*t -g*t^2/2
    


.. note::  No se pueden usar argumentos con *nombre* antes de los
  argumentos requeridos (en este caso ``t``).
  
  Tampoco se pueden usar argumentos sin su *nombre* después de haber
  incluido alguno con su nombre. Por ejemplo no son válidas las llamadas:
  
  .. code:: python
  
     caida_libre(t=2, 0.)
     caida_libre(2, v0=0., 1000)
  
  

Tipos mutables en argumentos opcionales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hay que tener cuidado cuando usamos valores por defecto con tipos que
pueden modificarse dentro de la función. Consideremos la siguiente
función:

.. code:: python

    def func2b(x1, x=[]):
      print('x entró a la función con el valor', x)
      x.append(x1)
      print('El nuevo valor de x es', x)

.. code:: python

    func2b(1)


.. parsed-literal::

    x entró a la función con el valor []
    El nuevo valor de x es [1]


.. code:: python

    func2b(2)


.. parsed-literal::

    x entró a la función con el valor [1]
    El nuevo valor de x es [1, 2]


El argumento opcional ``x`` tiene como valor por defecto una lista
vacía, entonces esperaríamos que el valor de ``x`` sea igual a ``x1``, y
en este caso imprima “El nuevo valor de x es [2]”. Sin embargo, entre
llamadas mantiene el valor de ``x`` anterior. El valor por defecto se
fija en la definición y en el caso de tipos mutables puede modificarse.

Número variable de argumentos y argumentos *keywords*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se pueden definir funciones que toman un número variable de argumentos
(como una lista), o que aceptan un diccionario como argumento. Este tipo
de argumentos se llaman argumentos *keyword* (``kwargs``). Una buena
explicación se encuentra en el `Tutorial de la
documentación <https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments>`__.
Ahora vamos a dar una explicación rápida. Consideremos la función ``f``,
que imprime sus argumentos:

.. code:: python

    def f(p, *args, **kwargs):
      print( f"p: {p}, tipo: {type(p)}")
      print( f"args: {args}, tipo: {type(args)}")
      print( f"kwargs: {kwargs}, tipo: {type(kwargs)}")

.. code:: python

    f(1.5,2, 3, 5, anteultimo= 9, ultimo = -1)


.. parsed-literal::

    p: 1.5, tipo: <class 'float'>
    args: (2, 3, 5), tipo: <class 'tuple'>
    kwargs: {'anteultimo': 9, 'ultimo': -1}, tipo: <class 'dict'>


Veamos que pasa cuando ejecutamos esta función con distintos argumentos.

.. code:: python

    f(1)                          # Solo el argumento posicional requerido


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (), tipo: <class 'tuple'>
    kwargs: {}, tipo: <class 'dict'>


.. code:: python

    f(1,2,3,4,5,6)                  # argumento posicional y args. No kwargs


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (2, 3, 4, 5, 6), tipo: <class 'tuple'>
    kwargs: {}, tipo: <class 'dict'>


.. code:: python

    f(1,2,3,4,5,otro=6)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (2, 3, 4, 5), tipo: <class 'tuple'>
    kwargs: {'otro': 6}, tipo: <class 'dict'>


En este ejemplo, el primer valor se asigna al argumento requerido ``p``,
el segundo a ``q`` y los siguientes a una variable que se llama
``args``, que es del tipo ``tuple``. No hay argumento ``kwargs`` y por
lo tanto la variable es un diccionario vacío

.. code:: python

    f(ultimo=-1, p=2)


.. parsed-literal::

    p: 2, tipo: <class 'int'>
    args: (), tipo: <class 'tuple'>
    kwargs: {'ultimo': -1}, tipo: <class 'dict'>


.. code:: python

    f(1, 'chau', (1,2,3), 4, ultimo=-1)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: ('chau', (1, 2, 3), 4), tipo: <class 'tuple'>
    kwargs: {'ultimo': -1}, tipo: <class 'dict'>


En estas otras llamadas a la función, todos los argumentos que se pasan
indicando el nombre se asignan a un diccionario.

Al definir una función, con la construcción ``*args`` se indica *“mapear
todos los argumentos posicionales no explícitos a una tupla llamada
``args``”*. Con ``**kwargs`` se indica “mapear todos los argumentos de
palabra clave no explícitos a un diccionario llamado ``kwargs``”. Esta
acción de convertir un conjunto de argumentos a una tuple o diccionario
se conoce como *empacar* o *empaquetar* los datos.

.. note::  Por supuesto, no es necesario utilizar los nombres “args” y
  “kwargs”. Podemos llamarlas de cualquier otra manera! los simbolos que
  indican cantidades arbitrarias de parametros son ``*`` y ``**``. Además
  es posible poner parametros “comunes” antes de los parametros
  arbitrarios, como se muestra en el ejemplo.
  
  

Un ejemplo de una función con número variable de argumentos puede ser la
función ``multiplica``:

.. code:: python

    def multiplica(*args):
      s = 1
      for a in args:
        s *= a
      return s

.. code:: python

    multiplica(2,5)




.. parsed-literal::

    10



.. code:: python

    multiplica(2,3,5,3,-1)




.. parsed-literal::

    -90



--------------

Ejercicios 4 (b)
----------------

2. Escriba funciones para analizar la divisibilidad de enteros:

   -  La función ``es_divisible`` que retorna ``True`` si el argumento
      ``x`` es divisible por alguno de los elemntos del segundo
      argumento: ``divisores``. El argumento ``divisores`` es opcional y
      si está presente es una variable del tipo lista que contiene los
      valores para los cuáles debemos examinar la divisibilidad.

   El valor por defecto de ``divisores`` es ``[2,3,5,7]``. Las
   siguientes expresiones deben retornar el mismo valor:
   ``python  es_divisible(x)   es_divisible(x, [2,3,5,7])``

   -  La función ``es_divisible_por`` cuyo primer argumento (mandatorio)
      es ``x``, y luego puede aceptar un número indeterminado de
      argumentos:

   .. code:: python

      es_divisible_por(x)  # retorna verdadero siempre
      es_divisible_por(x, 2) # verdadero si x es par
      es_divisible_por(x, 2, 3, 5, 7) # igual resultado que es_divisible(x)
      es_divisible_por(x, 2, 3, 5, 7, 9, 11, 13)  # o cualquier secuencia de argumentos debe funcionar

3. **PARA ENTREGAR.** Describimos una grilla de **sudoku** como un
   string de nueve líneas, cada una con 9 números, con números entre 1 y
   9. Escribir un conjunto de funciones que permitan chequear si una
   grilla de sudoku es correcta. Para que una grilla sea correcta deben
   cumplirse las siguientes condiciones

   -  Los números están entre 1 y 9
   -  En cada fila no deben repetirse
   -  En cada columna no deben repetirse
   -  En todas las regiones de 3x3 que no se solapan, empezando de
      cualquier esquina, no deben repetirse

   1. Escribir una función que convierta un string con formato a una
      lista bidimensional. El string estará dado con nueve números por
      línea, de la siguiente manera (los espacios en blanco en cada
      línea pueden variar):

   .. code:: python

      sudoku = """145327698
              839654127
              672918543
              496185372
              218473956
              753296481
              367542819
              984761235
              521839764"""

   2. Escribir una función ``check_repetidos()`` que tome por argumento
      una lista (unidimensional) y devuelva verdadero si la lista tiene
      elementos repetidos y falso en caso contrario.

   3. Escribir la función ``check_sudoku()`` que toma como argumento una
      grilla (como una lista bidimensional de ``9x9``) y devuelva
      verdadero si los números corresponden a la resolución correcta del
      Sudoku y falso en caso contrario. Note que debe verificar que los
      números no se repiten en filas, ni en columnas ni en recuadros de
      ``3x3``. Para obtener la posición de los recuadros puede
      investigar que hacen las líneas de código:

   .. code:: python

      j, k = (i // 3) * 3, (i % 3) * 3
      r = [grid[a][b] for a in range(j, j+3) for b in range(k, k+3)]

   suponiendo que ``grid`` es el nombre de nuestra lista bidimensional,
   cuando ``i`` toma valores entre ``0`` y ``8``.

   Debe enviar por correo electrónico, con asunto “04_SuApellido”, un
   programa llamado 04_SuApellido.py (en todos los casos utilice su
   apellido, no la palabra “SuApellido”) .

--------------

