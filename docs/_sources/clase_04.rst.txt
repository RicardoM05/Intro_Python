.. _clase_04:

Clase 4: Funciones
===================


Para utilizar una funcion en **Python**, como en la mayoría de los
lenguajes, se usa una notación similar a la de las funciones
matemáticas, con un nombre y uno o más argumentos entre paréntesis. Por
ejemplo, ya usamos la función ``sum()``, cuyo argumento es una lista o
una *tuple* de números (de cualquier tipo)

.. code:: python

    a = [1, 3.3, 5, 7.5, 2.2]
    sum(a)




.. parsed-literal::

    19.0



.. code:: python

    b = tuple(a)
    sum(b)




.. parsed-literal::

    19.0



Para usar una función necesitamos saber: - Qué hace - Que argumentos
podemos darle - Qué devuelve

pero no necesitamos saber cómo lo hace (al menos si no tenemos duda de
que la función es correcta).

Las funciones son objetos
-------------------------

Veamos en Python qué es una función:

.. code:: python

    sum




.. parsed-literal::

    <function sum(iterable, /, start=0)>



.. code:: python

    print




.. parsed-literal::

    <function print(*args, sep=' ', end='\n', file=None, flush=False)>



En **Python** ``function`` es un objeto, con una operación importante:
podemos llamarla (ejecutarla), en la forma:
``func(lista-de-argumentos)``

Como con todos los objetos, podemos definir una variable y asignarle una
función (algo así como lo que en C sería un puntero a funciones)

.. code:: python

    f = sum
    help(f)


.. parsed-literal::

    Help on built-in function sum in module builtins:
    
    sum(iterable, /, start=0)
        Return the sum of a 'start' value (default: 0) plus an iterable of numbers
        
        When the iterable is empty, return the start value.
        This function is intended specifically for use with numeric values and may
        reject non-numeric types.
    


.. code:: python

    print('¿f is sum? ', f is sum)
    print('f == sum? ', f== sum)
    print('f(a)=', f(a), '  sum(a)=', sum(a))


.. parsed-literal::

    ¿f is sum?  True
    f == sum?  True
    f(a)= 19.0   sum(a)= 19.0


También podemos crear un diccionario donde los valores sean funciones:

.. code:: python

    funciones = {'suma': sum, 'mínimo': min, 'máximo': max}

.. code:: python

    funciones['suma']




.. parsed-literal::

    <function sum(iterable, /, start=0)>



.. code:: python

    funciones['suma'](a)




.. parsed-literal::

    19.0



.. code:: python

    print('\n', 'a =', a,'\n')
    for k, v in funciones.items():
      print(k,"=", v(a))


.. parsed-literal::

    
     a = [1, 3.3, 5, 7.5, 2.2] 
    
    suma = 19.0
    mínimo = 1
    máximo = 7.5


Definición básica de funciones
------------------------------

Tomemos el ejemplo del tutorial de la documentación de Python. Vimos, al
introducir el elemento de control **while** una forma de calcular la
serie de Fibonacci. Usemos ese ejemplo para mostrar como se definen las
funciones

.. code:: python

    def fib(n):
      """Devuelve una lista con los términos
      de la serie de Fibonacci hasta n."""
      result = []
      a, b = 0, 1
      while a < n:
        result.append(a)    
        a, b = b, a+b
      return result


.. code:: python

    fib(100)




.. parsed-literal::

    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]



.. code:: python

    fib




.. parsed-literal::

    <function __main__.fib(n)>



.. code:: python

    help(fib)


.. parsed-literal::

    Help on function fib in module __main__:
    
    fib(n)
        Devuelve una lista con los términos
        de la serie de Fibonacci hasta n.
    


**Puntos a notar:**

-  Las funciones se definen utilizando la palabra ``def`` seguida por el
   nombre,
-  A continuación, entre paréntesis se escriben los argumentos, en este
   caso el entero ``n``,
-  La función devuelve (*retorna*) algo, en este caso una lista. Si una
   función no devuelve algo explícitamente, entonces devuelve ``None``.
-  Lo que devuelve la función se especifica mediante la palabra
   reservada ``return``
-  Al principio de la definición de la función se escribe el *string* de
   documentación

.. code:: python

    fib.__doc__




.. parsed-literal::

    'Devuelve una lista con los términos\n  de la serie de Fibonacci hasta n.'



Como segundo ejemplo, consideremos el ejercicio donde pedimos la
velocidad y altura de una pelota en caída libre. Pero esta vez definimos
una función para realizar los cálculos:

.. code:: python

    h_0 = 500                       # altura inicial en m
    v_0 = 0                         # velocidad inicial en m/s
    g = 9.8                         # aceleración de la gravedad en m/s^2
    def caida(t):
      v = v_0 - g*t
      h = h_0 - v_0*t - g*t**2/2.
      return v,h

.. code:: python

    print(caida(1))


.. parsed-literal::

    (-9.8, 495.1)


.. code:: python

    v, h = caida(1.5)

.. code:: python

    print(f'Para t = {1.5}, la velocidad será v={v:.2f} m/s\
     y estará a una altura {h:.2f} m')


.. parsed-literal::

    Para t = 1.5, la velocidad será v=-14.70 m/s y estará a una altura 488.98 m


.. code:: python

    v, h = caida(2.2)
    print(f'Para t = {2.2}, la velocidad será v={v:.2f} m/s y estará a una altura {h:.2f} m')


.. parsed-literal::

    Para t = 2.2, la velocidad será v=-21.56 m/s y estará a una altura 476.28 m


Podemos mejorar considerablemente la funcionalidad si le damos la
posibilidad al usuario de dar la posición y la velocidad iniciales

.. code:: python

    g = 9.8                         # aceleración de la gravedad en m/s^2
    def caida2(t, h_0, v_0):
      """Calcula la velocidad y posición de una partícula a tiempo t, para condiciones iniciales dadas
      h_0 es la altura inicial
      v_0 es la velocidad inicial
      Se utiliza el valor de aceleración de la gravedad g=9.8 m/s^2
      """
      v = v_0 - g*t
      h = h_0 - v_0*t - g*t**2/2.
      return v,h

.. code:: python

    t = 2.2
    v0 = 12
    alt = 100
    v,h = caida2(t, alt, v0)
    print(f'''Para caída desde {alt}m, con vel. inicial {v0}m/s, a t = {t}, 
    la velocidad será v={v}, y estará a una altura {h}''')


.. parsed-literal::

    Para caída desde 100m, con vel. inicial 12m/s, a t = 2.2, 
    la velocidad será v=-9.560000000000002, y estará a una altura 49.883999999999986


Notemos que podemos llamar a esta función de varias maneras. Podemos
llamarla con la constante, o con una variable indistintamente. En este
caso, el argumento está definido por su posición: El primero es la
altura inicial (h_0) y el segundo la velocidad inicial (v_0).

.. code:: python

    v0 = 12
    caida2(2.2, 100, v0)




.. parsed-literal::

    (-9.560000000000002, 49.883999999999986)



Pero en Python podemos usar el nombre de la variable en el llamado a la
función. Por ejemplo:

.. code:: python

    caida2(v_0=v0,t=2.2, h_0=100)




.. parsed-literal::

    (-9.560000000000002, 49.883999999999986)



.. code:: python

    caida2(t=2.2, h_0=100, 12)


::


      Input In [27]
        caida2(t=2.2, h_0=100, 12)
                                 ^
    SyntaxError: positional argument follows keyword argument



--------------

Ejercicios 4 (a)
----------------

1. Escriba una función que tome como un argumento una cadena de
   caracteres (*string*) y lo devuelva centrado con un ancho ``w``. Si
   la longitud del string es mayor que el ancho ``w`` debe retornar el
   *string* original. Los argumentos que toma la función son el *string*
   y el ancho.

2. Utilizando conjuntos (``set``), escriba una función que compruebe si
   un string contiene todas las vocales. La función debe devolver
   ``True`` o ``False``.

--------------


Argumentos de las funciones
---------------------------

Ámbito de las variables en los argumentos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consideremos la siguiente función

.. code:: python

    def func1(x):
      print('x entró a la función con el valor', x)
      x = 2
      print('El nuevo valor de x es', x)

.. code:: python

    x = 50
    print('Fuera de la función: Originalmente x vale',x)
    func1(x)
    print('Fuera de la función: Ahora x vale',x)  



.. parsed-literal::

    Fuera de la función: Originalmente x vale 50
    x entró a la función con el valor 50
    El nuevo valor de x es 2
    Fuera de la función: Ahora x vale 50


Vemos que la variable ``x`` que utilizamos como argumento de la función
debe ser diferente a la variable ``x`` que se define fuera de la
función, ya que su valor no cambia al salir.

Consideremos ahora la siguiente función:

.. code:: python

    def func2(x):
      print('x entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x = [2,7]
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x))

La función es muy parecida, sólo que le estamos dando a la variable
``x`` dentro de la función un nuevo valor del tipo ``lista``. Además
usamos la función ``id()`` para obtener la identidad de la variable

.. code:: python

    x = 50
    print('Fuera de la función: Originalmente x vale', x)
    print('Fuera de la función: Id:', id(x))
    func2(x)
    print('Fuera de la función: Ahora x vale', x)
    print('Fuera de la función: Id:', id(x))


.. parsed-literal::

    Fuera de la función: Originalmente x vale 50
    Fuera de la función: Id: 140648043740424
    x entró a la función con el valor 50
    Id adentro: 140648043740424
    El nuevo valor de x es [2, 7]
    Id adentro nuevo: 140647704981376
    Fuera de la función: Ahora x vale 50
    Fuera de la función: Id: 140648043740424


.. code:: python

    x = [50]
    print('Fuera de la función: Originalmente x vale', x)
    print('Fuera de la función: Id:', id(x))
    func2(x)
    print('Fuera de la función: Ahora x vale', x)
    print('Fuera de la función: Id:', id(x))


.. parsed-literal::

    Fuera de la función: Originalmente x vale [50]
    Fuera de la función: Id: 140647705134528
    x entró a la función con el valor [50]
    Id adentro: 140647705134528
    El nuevo valor de x es [2, 7]
    Id adentro nuevo: 140647705128320
    Fuera de la función: Ahora x vale [50]
    Fuera de la función: Id: 140647705134528


¿Qué está pasando acá?

-  Cuando se realiza la llamada a la función, se le pasa una copia del
   nombre ``x``.
-  Cuando le damos un nuevo valor dentro de la función, como en el caso
   ``x = [2, 7]``, entonces se crea una nueva variable y el nombre ``x``
   queda asociado a la nueva variable.
-  La variable original –definida fuera de la función– no cambia.

En el primer caso, como los escalares son inmutables (de la misma manera
que los strings y tuplas) no puede ser modificada, y al reasignar el
nombre siempre se crea una nueva variable (para cualquier tipo).

Consideremos estas variantes, donde el comportamiento entre tipos
mutables e inmutables son diferentes:

.. code:: python

    def func3(x):
      print('x entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x.append(2)
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x))

.. code:: python

    x = [50]
    print('Originalmente x vale',x)
    func3(x)
    print('Ahora x vale',x)  


.. parsed-literal::

    Originalmente x vale [50]
    x entró a la función con el valor [50]
    Id adentro: 140647705004032
    El nuevo valor de x es [50, 2]
    Id adentro nuevo: 140647705004032
    Ahora x vale [50, 2]


Como no estamos redefiniendo la variable, sino que la estamos
modificando, el nuevo valor se mantiene al terminar la ejecución de la
función. Otra variante:

.. code:: python

    def func4(x):
      print('x entró a la función con el valor', x)
      print('Id adentro:',id(x))
      x[0] = 2
      print('El nuevo valor de x es', x)
      print('Id adentro nuevo:',id(x))

.. code:: python

    x = [50]
    print('Originalmente x vale',x)
    func4(x)
    print('Ahora x vale',x)  


.. parsed-literal::

    Originalmente x vale [50]
    x entró a la función con el valor [50]
    Id adentro: 140647704983744
    El nuevo valor de x es [2]
    Id adentro nuevo: 140647704983744
    Ahora x vale [2]


Vemos que, cuando modificamos la variable (solo se puede para tipos
mutables), asignando un valor a uno o más de sus elementos o
agregando/removiendo elementos, la copia sigue apuntando a la variable
original y el valor de la variable, definida originalmente afuera,
cambia.

Funciones con argumentos opcionales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Las funciones pueden tener muchos argumentos. En **Python** pueden tener
un número variable de argumentos y pueden tener valores por *default*
para algunos de ellos. En el caso de la función de caída libre, vamos a
extenderlo de manera que podamos usarlo fuera de la tierra (o en otras
latitudes) permitiendo cambiar el valor de la gravedad y asumiendo que,
a menos que lo pidamos explícitamente se trata de una simple caída
libre:

.. code:: python

    def caida_libre(t, h0, v0=0., g=9.8):
      """Devuelve la velocidad y la posición de una partícula en
      caída libre para condiciones iniciales dadas
    
      Parameters
      ----------
      t : float
          el tiempo al que queremos realizar el cálculo
      h0: float 
          la altura inicial
      v0: float (opcional)
          la velocidad inicial (default = 0.0)
       g: float (opcional)
          valor de la aceleración de la gravedad (default = 9.8)
    
      Returns
      -------
      (v,h):  tuple of floats
           v= v0 - g*t
           h= h0 - v0*t -g*t^2/2
      
      """
      v = v0 - g*t
      h = h0 - v0*t - g*t**2/2.
      return v,h


.. code:: python

    # Desde 1000 metros con velocidad inicial cero
    print( caida_libre(2,1000))


.. parsed-literal::

    (-19.6, 980.4)


.. code:: python

    # Desde 1000 metros con velocidad inicial hacia arriba
    print(caida_libre(1, 1000, 10))


.. parsed-literal::

    (0.1999999999999993, 985.1)


.. code:: python

    # Desde 1000 metros con velocidad inicial cero
    print(caida_libre(h0= 1000, t=2))


.. parsed-literal::

    (-19.6, 980.4)


.. code:: python

    # Desde 1000 metros con velocidad inicial cero en la luna
    print( caida_libre( v0=0, h0=1000, t=14.2857137))


.. parsed-literal::

    (-139.99999426000002, 8.199999820135417e-05)


.. code:: python

    # Desde 1000 metros con velocidad inicial cero en la luna
    print( caida_libre( v0=0, h0=1000, t=14.2857137, g=1.625))


.. parsed-literal::

    (-23.2142847625, 834.1836870663262)


.. code:: python

    help(caida_libre)


.. parsed-literal::

    Help on function caida_libre in module __main__:
    
    caida_libre(t, h0, v0=0.0, g=9.8)
        Devuelve la velocidad y la posición de una partícula en
        caída libre para condiciones iniciales dadas
        
        Parameters
        ----------
        t : float
            el tiempo al que queremos realizar el cálculo
        h0: float 
            la altura inicial
        v0: float (opcional)
            la velocidad inicial (default = 0.0)
         g: float (opcional)
            valor de la aceleración de la gravedad (default = 9.8)
        
        Returns
        -------
        (v,h):  tuple of floats
             v= v0 - g*t
             h= h0 - v0*t -g*t^2/2
    


.. note::  No se pueden usar argumentos con *nombre* antes de los
  argumentos requeridos (en este caso ``t``).
  
  Tampoco se pueden usar argumentos sin su *nombre* después de haber
  incluido alguno con su nombre. Por ejemplo no son válidas las llamadas:
  
  .. code:: python
  
     caida_libre(t=2, 0.)
     caida_libre(2, v0=0., 1000)
  
  

Tipos mutables en argumentos opcionales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hay que tener cuidado cuando usamos valores por defecto con tipos que
pueden modificarse dentro de la función. Consideremos la siguiente
función:

.. code:: python

    def func2b(x1, x=[]):
      print('x entró a la función con el valor', x)
      x.append(x1)
      print('El nuevo valor de x es', x)

.. code:: python

    func2b(1)


.. parsed-literal::

    x entró a la función con el valor []
    El nuevo valor de x es [1]


.. code:: python

    func2b(2)


.. parsed-literal::

    x entró a la función con el valor [1]
    El nuevo valor de x es [1, 2]


El argumento opcional ``x`` tiene como valor por defecto una lista
vacía, entonces esperaríamos que el valor de ``x`` sea igual a ``x1``, y
en este caso imprima “El nuevo valor de x es [2]”. Sin embargo, entre
llamadas mantiene el valor de ``x`` anterior. El valor por defecto se
fija en la definición y en el caso de tipos mutables puede modificarse.

Número variable de argumentos y argumentos *keywords*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se pueden definir funciones que toman un número variable de argumentos
(como una lista), o que aceptan un diccionario como argumento. Este tipo
de argumentos se llaman argumentos *keyword* (``kwargs``). Una buena
explicación se encuentra en el `Tutorial de la
documentación <https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments>`__.
Ahora vamos a dar una explicación rápida. Consideremos la función ``f``,
que imprime sus argumentos:

.. code:: python

    def f(p, *args, **kwargs):
      print( f"p: {p}, tipo: {type(p)}")
      print( f"args: {args}, tipo: {type(args)}")
      print( f"kwargs: {kwargs}, tipo: {type(kwargs)}")

.. code:: python

    f(1)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (), tipo: <class 'tuple'>
    kwargs: {}, tipo: <class 'dict'>


.. code:: python

    f(1,2,3)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (2, 3), tipo: <class 'tuple'>
    kwargs: {}, tipo: <class 'dict'>


.. code:: python

    f(1,2,3,4,5,6)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (2, 3, 4, 5, 6), tipo: <class 'tuple'>
    kwargs: {}, tipo: <class 'dict'>


En este ejemplo, el primer valor se asigna al argumento requerido ``p``,
y los siguientes a una variable que se llama ``args``, que es del tipo
``tuple``

.. code:: python

    f(1.5,2, 3, 5, anteultimo= 9, ultimo = -1)


.. parsed-literal::

    p: 1.5, tipo: <class 'float'>
    args: (2, 3, 5), tipo: <class 'tuple'>
    kwargs: {'anteultimo': 9, 'ultimo': -1}, tipo: <class 'dict'>


.. code:: python

    f(1, (1,2,3), 4, ultimo=-1)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: ((1, 2, 3), 4), tipo: <class 'tuple'>
    kwargs: {'ultimo': -1}, tipo: <class 'dict'>


En estas otras llamadas a la función, todos los argumentos que se pasan
indicando el nombre se asignan a un diccionario.

.. code:: python

    help(print)


.. parsed-literal::

    Help on built-in function print in module builtins:
    
    print(*args, sep=' ', end='\n', file=None, flush=False)
        Prints the values to a stream, or to sys.stdout by default.
        
        sep
          string inserted between values, default a space.
        end
          string appended after the last value, default a newline.
        file
          a file-like object (stream); defaults to the current sys.stdout.
        flush
          whether to forcibly flush the stream.
    


Al definir una función, con la construcción ``*args`` se indica *“mapear
todos los argumentos posicionales no explícitos a una tupla llamada
``args``”*. Con ``**kwargs`` se indica “mapear todos los argumentos de
palabra clave no explícitos a un diccionario llamado ``kwargs``”. Esta
acción de convertir un conjunto de argumentos a una tuple o diccionario
se conoce como *empacar* o *empaquetar* los datos.

.. note::  Por supuesto, no es necesario utilizar los nombres “args” y
  “kwargs”. Podemos llamarlas de cualquier otra manera! los simbolos que
  indican cantidades arbitrarias de parametros son ``*`` y ``**``. Además
  es posible poner parametros “comunes” antes de los parametros
  arbitrarios, como se muestra en el ejemplo.
  
  

Exploremos otras variantes de llamadas a la función:

.. code:: python

    f(1, ultimo=-1)


.. parsed-literal::

    p: 1, tipo: <class 'int'>
    args: (), tipo: <class 'tuple'>
    kwargs: {'ultimo': -1}, tipo: <class 'dict'>


.. code:: python

    f(1, ultimo=-1, 2)


::


      Input In [29]
        f(1, ultimo=-1, 2)
                         ^
    SyntaxError: positional argument follows keyword argument



.. code:: python

    f(ultimo=-1, p=2)


.. parsed-literal::

    p: 2, tipo: <class 'int'>
    args: (), tipo: <class 'tuple'>
    kwargs: {'ultimo': -1}, tipo: <class 'dict'>


Un ejemplo de una función con número variable de argumentos puede ser la
función ``multiplica``:

.. code:: python

    def multiplica(*args):
      s = 1
      for a in args:
        s *= a
      return s

.. code:: python

    multiplica(2,5)




.. parsed-literal::

    10



.. code:: python

    multiplica(2,3,5,9,12)




.. parsed-literal::

    3240



--------------

Ejercicios 4 (b)
----------------

3. Escriba funciones para analizar la divisibilidad de enteros:

   -  La función ``es_divisible1(x)`` que retorna verdadero si x es
      divisible por alguno de ``2,3,5,7`` o falso en caso contrario.
   -  La función ``es_divisible_por_lista`` que cumple la misma función
      que ``es_divisible1`` pero recibe dos argumentos: el entero ``x``
      y una variable del tipo lista que contiene los valores para los
      cuáles debemos examinar la divisibilidad. Las siguientes
      expresiones deben retornar el mismo valor:

   .. code:: python

      es_divisible1(x) 
      es_divisible_por_lista(x, [2,3,5,7])
      es_divisible_por_lista(x)

   -  La función ``es_divisible_por`` cuyo primer argumento (mandatorio)
      es ``x``, y luego puede aceptar un número indeterminado de
      argumentos:

   .. code:: python

      es_divisible_por(x)  # retorna verdadero siempre
      es_divisible_por(x, 2) # verdadero si x es par
      es_divisible_por(x, 2, 3, 5, 7) # igual resultado que es_divisible1(x) e igual a es_divisible_por_lista(x)
      es_divisible_por(x, 2, 3, 5, 7, 9, 11, 13)  # o cualquier secuencia de argumentos debe funcionar

--------------
Empacar y desempacar argumentos
-------------------------------

Cuando en **Python** creamos una función que acepta un número arbitrario
de argumentos estamos utilizando una habilidad del lenguaje que es el
“empaquetamiento” y “desempaquetamiento” automático de variables.

Al definir un número variable de argumentos de la forma:

.. code:: python

   def f(*v):
   ...

y luego utilizarla en alguna de las formas:

.. code:: python

   f(1)
   f(1,'hola')
   f(a,2,3.5, 'hola')

**Python** automáticamente convierte los argumentos en una única tupla:

.. code:: python

   f(1)                 --> v = (1,)
   f(1,'hola')          --> v = (1,'hola')
   f(a,2,3.5, 'hola')   --> v = (a,2,3.5,'hola')

Análogamente, cuando utilizamos funciones podemos desempacar múltiples
valores en los argumentos de llamada a las funciones.

Si definimos una función que recibe un número determinado de argumentos

.. code:: python

   def g(a, b, c):
   ...

y definimos una lista (o tupla)

.. code:: python

   t1 = [a1, b1, c1]

podemos realizar la llamada a la función utilizando la notación
“asterisco” o “estrella”

.. code:: python

   g(*t1)             -->  g(a1, b1, c1)

Esta notación no se puede utilizar en cualquier contexto. Por ejemplo,
es un error tratar de hacer

.. code:: python

   t2 = *t1

pero en el contexto de funciones podemos “desempacarlos” para
convertirlos en varios argumentos que acepta la función usando la
expresión con asterisco. Veamos lo que esto quiere decir con la función
``caida_libre()`` definida anteriormente

.. code:: python

    def caida_libre(t, h0, v0 = 0., g=9.8):
      """Devuelve la velocidad y la posición de una partícula en
      caída libre para condiciones iniciales dadas
    
      Parameters
      ----------
      t : float
          el tiempo al que queremos realizar el cálculo
      h0: float 
          la altura inicial
      v0: float (opcional)
          la velocidad inicial (default = 0.0)
       g: float (opcional)
          valor de la aceleración de la gravedad (default = 9.8)
    
      Returns
      -------
      (v,h):  tuple of floats
           v= v0 - g*t
           h= h0 - v0*t -g*t^2/2
      
      """
      v = v0 - g*t
      h = h0 - v0*t - g*t**2/2.
      return v,h


.. code:: python

    datos = (5.4, 1000., 0.)        # Una lista (tuple en realidad)
    # print (caida_libre(datos[0], datos[1], datos[2]))
    print (caida_libre(*datos))


.. parsed-literal::

    (-52.92000000000001, 857.116)


En la llamada a la función, la expresión ``*datos`` le indica al
intérprete Python que la secuencia (tuple) debe convertirse en una
sucesión de argumentos, que es lo que acepta la función.

Similarmente, para desempacar un diccionario usamos la notación
``**diccionario``:

.. code:: python

    # diccionario, caída libre en la luna
    otros_datos = {'t':5.4, 'h0': 1000., "g" : 1.625} 
    v, h = caida_libre(**otros_datos)
    print ('v={}, h={}'.format(v,h))



.. parsed-literal::

    v=-8.775, h=976.3075


En resumen:

-  la notación ``(*datos)`` convierte la tuple (o lista) en los tres
   argumentos que acepta la función caída libre. Los siguientes llamados
   son equivalentes:

.. code:: python

   caida_libre(*datos)
   caida_libre(datos[0], datos[1], datos[2])
   caida_libre(5.4, 1000., 0.)

-  la notación ``(**otros_datos)`` desempaca el diccionario en pares
   ``clave=valor``, siendo equivalentes los dos llamados:

.. code:: python

   caida_libre(**otros_datos)
   caida_libre(t=5.4, h0=1000., g=0.2)

Funciones que devuelven funciones
---------------------------------

Las funciones pueden ser pasadas como argumento y pueden ser retornadas
por una función, como cualquier otro objeto (números, listas, tuples,
cadenas de caracteres, diccionarios, etc). Veamos un ejemplo simple de
funciones que devuelven una función:

.. code:: python

    def crear_potencia(n):
      "Devuelve la función x^n"
      def potencia(x):
        "potencia {}-esima de x".format(n)
        return x**n
      return potencia

.. code:: python

    f = crear_potencia(3)
    print(f)
    cubos = [f(j) for j in range(5)]


.. parsed-literal::

    <function crear_potencia.<locals>.potencia at 0x7f12bc236520>


.. code:: python

    cubos




.. parsed-literal::

    [0, 1, 8, 27, 64]



.. code:: python

    help(f)


.. parsed-literal::

    Help on function potencia in module __main__:
    
    potencia(x)
    


.. code:: python

    help(crear_potencia)


.. parsed-literal::

    Help on function crear_potencia in module __main__:
    
    crear_potencia(n)
        Devuelve la función x^n
    


Ejemplo: Polinomio interpolador
-------------------------------

Veamos ahora una función que retorna una función. Supongamos que tenemos
una tabla de puntos ``(x,y)`` por los que pasan nuestros datos y
queremos interpolar los datos con un polinomio.

Sabemos que dados ``N`` puntos, hay un único polinomio de grado ``N``
que pasa por todos los puntos. En este ejemplo utilizamos la fórmula de
Lagrange para obtenerlo.

.. code:: python

    # %load scripts/ejemplo_05_2.py
    def polinomio_interp(x, y):
      """Devuelve el polinomio interpolador que pasa por los puntos (x_i, y_i)
    
        Warning: La implementación es numéricamente inestable. Funciona para algunos puntos (menor a 20)
    
      Keyword Arguments:
      x -- Lista con los valores de x
      y -- Lista con los valores de y
      """
    
      M = len(x)
    
      def polin(xx):
        """Evalúa el polinomio interpolador de Lagrange"""
        P = 0
    
        for j in range(M):
          pt = y[j]
          for k in range(M):
            if k == j:
              continue
            fac = x[j] - x[k]
            pt *= (xx - x[k]) / fac
          P += pt
        return P
    
      return polin


Lo que obtenemos al llamar a esta función es una función

.. code:: python

    f = polinomio_interp([0,1], [0,2])

.. code:: python

    f




.. parsed-literal::

    <function __main__.polinomio_interp.<locals>.polin(xx)>



.. code:: python

    help(f)


.. parsed-literal::

    Help on function polin in module __main__:
    
    polin(xx)
        Evalúa el polinomio interpolador de Lagrange
    


.. code:: python

    f(3.4)




.. parsed-literal::

    6.8



Este es el resultado esperado porque queremos el polinomio que pasa por
dos puntos (una recta), y en este caso es la recta :math:`y = 2x`.
Veamos cómo usarlo, en forma más general:

.. code:: python

    # %load scripts/ejemplo_05_3
    from ejemplo_05_2 import polinomio_interp
    
    xmax = 5
    step = 0.2
    N = int(5 / step)
    
    x2, y2 = [1, 2, 3], [1, 4, 9]   # x^2
    f2 = polinomio_interp(x2, y2)
    
    x3, y3 = [0, 1, 2, 3], [0, 2, 16, 54]  # 2 x^3
    f3 = polinomio_interp(x3, y3)
    
    print('\n x   f2(x)   f3(x)\n' + 18 * '-')
    for j in range(N):
      x = step * j
      print(f'{x:.1f}  {f2(x):5.2f}  {f3(x):6.2f}')



.. parsed-literal::

    
     x   f2(x)   f3(x)
    ------------------
    0.0   0.00    0.00
    0.2   0.04    0.02
    0.4   0.16    0.13
    0.6   0.36    0.43
    0.8   0.64    1.02
    1.0   1.00    2.00
    1.2   1.44    3.46
    1.4   1.96    5.49
    1.6   2.56    8.19
    1.8   3.24   11.66
    2.0   4.00   16.00
    2.2   4.84   21.30
    2.4   5.76   27.65
    2.6   6.76   35.15
    2.8   7.84   43.90
    3.0   9.00   54.00
    3.2  10.24   65.54
    3.4  11.56   78.61
    3.6  12.96   93.31
    3.8  14.44  109.74
    4.0  16.00  128.00
    4.2  17.64  148.18
    4.4  19.36  170.37
    4.6  21.16  194.67
    4.8  23.04  221.18


--------------

Ejercicios 04 (c)
-----------------

4. Escriba una función ``crear_sen(A, w)`` que acepte dos números reales
   :math:`A, w` como argumentos y devuelva la función ``f(x)``.

Al evaluar la función ``f`` en un dado valor :math:`x` debe dar el
resultado: :math:`f(x) = A \sin(w x)` tal que se pueda utilizar de la
siguiente manera:

.. code:: python

   f = crear_sen(3, 1.5)
   f(2)          # Debería imprimir el resultado de 3*sin(1.5*2)=0.4233600241796016

--------------

Funciones que toman como argumento una función
----------------------------------------------

.. code:: python

    def aplicar_fun(f, L):
      """Aplica la función f a cada elemento del iterable L 
      devuelve una lista con los resultados.
      
      IMPORTANTE: Notar que no se realiza ninguna comprobación de validez
      """
      return [f(x) for x in L]

.. code:: python

    import math as m
    Lista = list(range(1,10))
    t = aplicar_fun(m.sin, Lista)

.. code:: python

    t




.. parsed-literal::

    [0.8414709848078965,
     0.9092974268256817,
     0.1411200080598672,
     -0.7568024953079282,
     -0.9589242746631385,
     -0.27941549819892586,
     0.6569865987187891,
     0.9893582466233818,
     0.4121184852417566]



El ejemplo anterior se podría escribir

.. code:: python

    Lista = list(range(5))
    aplicar_fun(crear_potencia(3), Lista)




.. parsed-literal::

    [0, 1, 8, 27, 64]



Notar que definimos la función ``aplicar_fun()`` que recibe una función
y una secuencia, pero no necesariamente una lista, por lo que podemos
aplicarla directamente a ``range``:

.. code:: python

    aplicar_fun(crear_potencia(3), range(5)) 




.. parsed-literal::

    [0, 1, 8, 27, 64]



Además, debido a su definición, el primer argumento de la función
``aplicar_fun()`` no está restringida a funciones numéricas pero al
usarla tenemos que asegurar que la función y el iterable (lista) que
pasamos como argumentos son compatibles.

Veamos otro ejemplo:

.. code:: python

    s = ['hola', 'chau']
    print(aplicar_fun(str.upper, s))


.. parsed-literal::

    ['HOLA', 'CHAU']


donde ``str.upper`` es una función definida en **Python**, que convierte
a mayúsculas el string dado ``str.upper('hola') = 'HOLA'``.

Aplicacion 1: Ordenamiento de listas
------------------------------------

Consideremos el problema del ordenamiento de una lista de strings. Como
vemos el resultado usual no es necesariamente el deseado

.. code:: python

    s1 = ['Estudiantes', 'caballeros', 'Python', 'Curso', 'pc', 'aereo']
    print(s1)
    print(sorted(s1))


.. parsed-literal::

    ['Estudiantes', 'caballeros', 'Python', 'Curso', 'pc', 'aereo']
    ['Curso', 'Estudiantes', 'Python', 'aereo', 'caballeros', 'pc']


Acá ``sorted`` es una función, similar al método ``str.sort()`` que
mencionamos anteriormente, con la diferencia que devuelve una nueva
lista con los elementos ordenados. Como los elementos son *strings*, la
comparación se hace respecto a su posición en el abecedario. En este
caso no es lo mismo mayúsculas o minúsculas.

.. code:: python

    s2 = [s.lower() for s in s1]
    print(s2)
    print(sorted(s2))


.. parsed-literal::

    ['estudiantes', 'caballeros', 'python', 'curso', 'pc', 'aereo']
    ['aereo', 'caballeros', 'curso', 'estudiantes', 'pc', 'python']


Posiblemente queremos el orden que obtuvimos en segundo lugar pero con
los elementos dados originalmente (con sus mayúsculas y minúsculas
originales). Para poder modificar el modo en que se ordenan los
elementos, la función ``sorted`` (y el método ``sort``) tienen el
argumento opcional ``key``

.. code:: python

    help(sorted)


.. parsed-literal::

    Help on built-in function sorted in module builtins:
    
    sorted(iterable, /, *, key=None, reverse=False)
        Return a new list containing all items from the iterable in ascending order.
        
        A custom key function can be supplied to customize the sort order, and the
        reverse flag can be set to request the result in descending order.
    


Como vemos tiene un argumento opcional ``key`` que es una función.
Veamos algunos ejemplos de su uso

.. code:: python

    sorted(s1, key=str.lower)




.. parsed-literal::

    ['aereo', 'caballeros', 'Curso', 'Estudiantes', 'pc', 'Python']



Como vemos, los strings están ordenados adecuadamente. Si queremos
ordenarlos por longitud de la palabra

.. code:: python

    sorted(s1, key=len)




.. parsed-literal::

    ['pc', 'Curso', 'aereo', 'Python', 'caballeros', 'Estudiantes']



Supongamos que queremos ordenarla alfabéticamente por la segunda letra

.. code:: python

    def segunda(a):
      return a[1]
    
    sorted(s1, key=segunda)




.. parsed-literal::

    ['caballeros', 'pc', 'aereo', 'Estudiantes', 'Curso', 'Python']



Funciones anónimas
------------------

En ocasiones como esta suele ser más rápido (o conveniente) definir la
función, que se va a utilizar una única vez, sin darle un nombre. Estas
se llaman funciones *lambda*, y el ejemplo anterior se escribiría

.. code:: python

    sorted(s1, key=lambda a: a[1])




.. parsed-literal::

    ['caballeros', 'pc', 'aereo', 'Estudiantes', 'Curso', 'Python']



Si queremos ordenarla alfabéticamente empezando desde la última letra:

.. code:: python

    sorted(s1, key=lambda a: str.lower(a[::-1]))




.. parsed-literal::

    ['pc', 'Python', 'aereo', 'Curso', 'Estudiantes', 'caballeros']



Este es un ejemplo de uso de las funciones anónimas ``lambda``. La forma
general de las funciones ``lambda`` es:

.. code:: python

   lambda x,y,z: expresión_de(x,y,z)

por ejemplo en el ejemplo anterior, para calcular :math:`(n+1) x^n`,
hicimos:

.. code:: python

   lambda x: (n+1) * x**n

Ejemplo: Integración numérica
-----------------------------

Veamos en más detalle el caso de funciones que reciben como argumento
otra función, estudiando un caso usual: una función de integración debe
recibir como argumento al menos una función a integrar y los límites de
integración:

.. code:: python

    # %load scripts/05_ejemplo_1.py
    def integrate_simps(f, a, b, N=10):
      """Calcula numéricamente la integral de la función en el intervalo dado
      utilizando la regla de Simpson
    
      Keyword Arguments:
      f -- Función a integrar
      a -- Límite inferior
      b -- Límite superior
      N -- El intervalo se separa en 2*N intervalos
      """
      h = (b - a) / (2 * N)
      I = f(a) - f(b)
      for j in range(1, N + 1):
        x2j = a + 2 * j * h
        x2jm1 = a + (2 * j - 1) * h
        I += 2 * f(x2j) + 4 * f(x2jm1)
      return I * h / 3


En este ejemplo programamos la fórmula de integración de Simpson para
obtener la integral de una función ``f(x)`` provista por el usuario, en
un dado intervalo:

.. math::


   \int _{a}^{b}f(x)\,dx\approx \frac{h}{3} \bigg[ f(x_{0}) + 2 \sum_{j=1}^{n/2} f(x_{2j}) + 4 \sum_{j=1}^{n/2} f(x_{2j-1}) - f(x_{n})\bigg]

¿Cómo usamos la función de integración?

.. code:: python

    def potencia2(x):
      return x**2
    
    integrate_simps(potencia2, 0, 3, 7)




.. parsed-literal::

    9.0



Acá definimos una función, y se la pasamos como argumento a la función
de integración.

Uso de funciones anónimas
~~~~~~~~~~~~~~~~~~~~~~~~~

Veamos como sería el uso de funciones anónimas en este contexto

.. code:: python

    integrate_simps(lambda x: x**2, 0, 3, 7)




.. parsed-literal::

    9.0



La notación es un poco más corta, que es cómodo pero no muy relevante
para un caso. Si queremos, por ejemplo, aplicar el integrador a una
familia de funciones la notación se simplifica notablemente:

.. code:: python

    print('Integrales:')
    a = 0
    b = 3
    for n in range(6):
      I = integrate_simps(lambda x: (n + 1) * x**n, a, b, 10)
      print(f'I ( {n+1} x^{n}, {a}, {b} ) = {I:.5f}')



.. parsed-literal::

    Integrales:
    I ( 1 x^0, 0, 3 ) = 3.00000
    I ( 2 x^1, 0, 3 ) = 9.00000
    I ( 3 x^2, 0, 3 ) = 27.00000
    I ( 4 x^3, 0, 3 ) = 81.00000
    I ( 5 x^4, 0, 3 ) = 243.00101
    I ( 6 x^5, 0, 3 ) = 729.00911


--------------

Ejercicios 04 (d)
-----------------

5. Escriba una serie de funciones que permitan trabajar con polinomios.
   Vamos a representar a un polinomio como una lista de números reales,
   donde cada elemento corresponde a un coeficiente que acompaña una
   potencia

   -  Una función que devuelva el orden del polinomio (un número entero)
   -  Una función que sume dos polinomios y devuelva un polinomio
      (objeto del mismo tipo)
   -  Una función que multiplique dos polinomios y devuelva el resultado
      en otro polinomio
   -  Una función devuelva la derivada del polinomio (otro polinomio).
   -  Una función que acepte el polinomio y devuelva la función
      correspondiente.

6. **PARA ENTREGAR.** Describimos una grilla de **sudoku** como un
   string de nueve líneas, cada una con 9 números, con números entre 1 y
   9. Escribir un conjunto de funciones que permitan chequear si una
   grilla de sudoku es correcta. Para que una grilla sea correcta deben
   cumplirse las siguientes condiciones

   -  Los números están entre 1 y 9
   -  En cada fila no deben repetirse
   -  En cada columna no deben repetirse
   -  En todas las regiones de 3x3 que no se solapan, empezando de
      cualquier esquina, no deben repetirse

   1. Escribir una función que convierta un string con formato a una
      lista bidimensional. El string estará dado con nueve números por
      línea, de la siguiente manera (los espacios en blanco en cada
      línea pueden variar):

   .. code:: python

      sudoku = """145327698
              839654127
              672918543
              496185372
              218473956
              753296481
              367542819
              984761235
              521839764"""

   2. Escribir una función ``check_repetidos()`` que tome por argumento
      una lista (unidimensional) y devuelva verdadero si la lista tiene
      elementos repetidos y falso en caso contrario (puede ser
      conveniente explorar el uso de ``set``).

   3. Escribir la función ``check_sudoku()`` que toma como argumento una
      grilla (como una lista bidimensional de ``9x9``) y devuelva
      verdadero si los números corresponden a la resolución correcta del
      Sudoku y falso en caso contrario. Note que debe verificar que los
      números no se repiten en filas, ni en columnas ni en recuadros de
      ``3x3``. Para obtener la posición de los recuadros, puede
      investigar que hacen las líneas de código:

   .. code:: python

      j, k = (i // 3) * 3, (i % 3) * 3
      r = [grid[a][b] for a in range(j, j+3) for b in range(k, k+3)]

   suponiendo que ``grid`` es el nombre de nuestra lista bidimensional,
   cuando ``i`` toma valores entre ``0`` y ``8``.

--------------

.
