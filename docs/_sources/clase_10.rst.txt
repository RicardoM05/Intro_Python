.. _clase_10:

Clase 10: Más información sobre **Numpy** 
===========================================


Creación y operación sobre **Numpy** arrays
-------------------------------------------

Vamos a ver algunas características de los ``arrays`` de Numpy en un
poco más de detalle

Funciones para crear arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vimos varios métodos que permiten crear e inicializar arrays

.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt

.. code:: python

    a= {}
    a['empty unid'] = np.empty(10)    #  Creación de un array de 10 elementos
    a['zeros unid'] = np.zeros(10)    #  Creación de un array de 10 elementos inicializados en cero
    a['zeros bidi'] = np.zeros((5,2)) #  Array bidimensional 10 elementos con *shape* 5x2
    a['ones bidi'] = np.ones((5,2)) #  Array bidimensional 10 elementos con *shape* 5x2, inicializado en 1
    a['arange'] = np.arange(10)  # Array inicializado con una secuencia
    a['lineal'] = np.linspace(0,10,5)  # Array inicializado con una secuencia equiespaciada
    a['log'] = np.logspace(0,2,10)  # Array inicializado con una secuencia con espaciado logarítmico
    a['diag'] = np.diag(np.arange(5)) # Matriz diagonal a partir de un vector
    
    for k,v in a.items():
      print('Array {}:\n {}\n'.format(k,v), 80*"*")

La función ``np.tile(A, reps)`` permite crear un array repitiendo el
patrón ``A`` las veces indicada por ``reps`` a lo largo de cada eje

.. code:: python

    a = np.arange(1,6,2)
    a

.. code:: python

    np.tile(a, 2)

.. code:: python

    a1=np.tile(a, (1,2))

.. code:: python

    a1.shape

.. code:: python

    a1

.. code:: python

    b = [[1,2],[3,4]]

.. code:: python

    print(b)

.. code:: python

    np.tile(b,(1,2))

.. code:: python

    np.tile(b, (2,1))

En general, el argumento ``reps = (nrows, ncols)`` indica el número de
repeticiones en filas (hacia abajo) y columnas (hacia la derecha),
creando nuevas dimensiones si es necesario

.. code:: python

    a

.. code:: python

    np.tile(a, (3,2))

Funciones que actúan sobre arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Numpy incluye muchas funciones matemáticas que actúan sobre arrays
completos (de una o más dimensiones). La lista completa se encuentra en
la
`documentación <http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs>`__
e incluye:

.. code:: python

    x = np.linspace(np.pi/180, np.pi,7)
    y = np.geomspace(10,100,7)

.. code:: python

    print(x)
    print(y)
    print(x+y)                      # Suma elemento a elemento
    print(x*y)                      # Multiplicación elemento a elemento
    print(y/x)                      # División elemento a elemento
    print(x//2)                     # División entera elemento a elemento

.. code:: python

    print('x =', x)
    print('square\n', x**2)              # potencias
    print('sin\n',np.sin(x))             # Seno (np.cos, np.tan)
    print("tanh\n",np.tanh(x))           # tang hiperb (np.sinh, np.cosh)
    print('exp\n', np.exp(-x))           # exponenciales
    print('log\n', np.log(x))            # logaritmo en base e (np.log10)
    print('abs\n',np.absolute(x))        # Valor absoluto
    print('resto\n', np.remainder(x,2))  # Resto

Productos entre arrays y productos vectoriales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    # Creamos arrays unidimensionales (vectores) y bidimensionales (matrices)
    v1 = np.array([2, 3, 4])
    v2 = np.array([1, 1, 1])
    A = np.arange(1,13,2).reshape(2, 3)
    B = np.linspace(0.5,11.5,12).reshape(3, 4)

.. code:: python

    print(A)

.. code:: python

    print(B)

.. code:: python

    print(v1*v2)

.. code:: python

    print(A*v1)

Los productos se realizan “elemento a elemento”, si queremos obtener
“productos internos” o productos entre matrices (o matrices y vectores)

.. code:: python

    print(v1, '.', v2, '=', np.dot(v1, v2))

.. code:: python

    print( A, 'x', v1, '=', np.dot(A, v1))


.. code:: python

    print(A.shape, B.shape)

.. code:: python

    print( 'A x B = \n',np.dot(A, B) )

.. code:: python

    print( 'B^t x A^t =\n ',np.dot(B.T, A.T))

Además, el módulo numpy.linalg incluye otras funcionalidades como
determinantes, normas, determinación de autovalores y autovectores,
descomposiciones, etc.

Comparaciones entre arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~

La comparación, como las operaciones y aplicación de funciones se
realiza “elemento a elemento”.

=============================================== ==========
Funciones                                       Operadores
=============================================== ==========
greater(x1, x2, /[, out, where, casting, …])    (x1 > x2)
greater_equal(x1, x2, /[, out, where, …])       (x1 >= x2)
less(x1, x2, /[, out, where, casting, …])       (x1 < x2)
less_equal(x1, x2, /[, out, where, casting, …]) (x1 =< x2)
not_equal(x1, x2, /[, out, where, casting, …])  (x1 != x2)
equal(x1, x2, /[, out, where, casting, …])      (x1 == x2)
=============================================== ==========

.. code:: python

    z = np.array((-1,3,4,0.5,2,9,0.7))

.. code:: python

    print(x)
    print(y)
    print(z)

.. code:: python

    c1 = x <= z
    c2 = np.less_equal(z,y)
    c3 = np.less_equal(x,y)
    print(c1)
    print(c2)
    print(c3)


.. code:: python

    c1                              # Veamos que tipo de array es:

.. code:: python

    np.sum(c1), np.sum(c2), c3.sum()

Como vemos, las comparaciones nos dan un vector de variables lógicas.
Cuando queremos combinar condiciones no funciona usar las palabras
``and`` y ``or`` de *Python* porque estaríamos comparando los dos
elementos (arrays completos).

.. code:: python

    print(np.logical_and(c1, c2))
    print(c1 & c2)
    print(np.logical_and(c2, c3))
    print(c2 & c3)

.. code:: python

    print(np.logical_or(c1, c2))
    print(c1 | c2)
    print(np.logical_or(c2, c3))
    print(c2 | c3)

.. code:: python

    print(np.logical_xor(c1, c2))
    print(np.logical_xor(c2, c3))

Atributos de *arrays*
---------------------

Los array tienen otras propiedades, que pueden explorarse apretando
``<TAB>`` en una terminal o notebook de **IPython** o leyendo la
documentación de `Numpy <http://docs.scipy.org/doc/numpy/user>`__, o
utilizando la función ``dir(arr)`` (donde ``arr`` es una variable del
tipo array) o ``dir(np.ndarray)``.

En la tabla se muestra una lista de los atributos de los numpy array

.. image:: figuras/array_atr.png

Exploremos algunas de ellas

reshape
~~~~~~~

.. code:: python

    arr= np.arange(12)                         # Vector
    print("Vector original:\n", arr)
    arr2= arr.reshape((3,4))                   # Le cambiamos la forma a matriz de 3x4
    print("Cambiando la forma a 3x4:\n", arr2)
    arr3= np.reshape(arr,(4,3))                # Le cambiamos la forma a matriz de 4x3
    print("Cambiando la forma a 4x3:\n", arr3)

.. code:: python

    arr2[0,0] = 5
    arr2[2,1] = -9

.. code:: python

    print(arr2)

.. code:: python

    print(arr)

.. code:: python

    print(arr3)

.. code:: python

    try:
        arr.reshape((3,3))   # Si la nueva forma no es adecuada, falla
    except ValueError as e:
        print("Error: la nueva forma es incompatible:", e)

transpose
~~~~~~~~~

.. code:: python

    print('Transpose:\n', arr2.T)
    print('Transpose:\n', np.transpose(arr2))

min, max
~~~~~~~~

Las funciones para encontrar mínimo y máximo pueden aplicarse tanto a
vectores como a arrays\` con más dimensiones. En este último caso puede
elegirse si se trabaja sobre uno de los ejes:

.. code:: python

    print(arr2)
    print(np.max(arr2))
    print(np.max(arr2,axis=0))
    print(np.max(arr2,axis=1))


.. code:: python

    np.max(arr2[1,:])

El primer eje ``(axis=0)`` corresponde a las columnas (convención del
lenguaje ``C``), y por lo tanto dará un valor por cada columna.

Si no damos el argumento opcional ``axis`` ambas funciones nos darán el
mínimo o máximo de todos los elementos. Si le damos un eje nos devolverá
el mínimo a lo largo de ese eje.

argmin, argmax
~~~~~~~~~~~~~~

Estas funciones trabajan de la misma manera que ``min`` y ``max`` pero
devuelve los índices en lugar de los valores.

.. code:: python

    print(np.argmax(arr2))
    print(np.argmax(arr2,axis=0))
    print(np.argmax(arr2,axis=1))


sum, prod, mean, std
~~~~~~~~~~~~~~~~~~~~

.. code:: python

    print(arr2)
    print('sum', np.sum(arr2))
    print('sum, 0', np.sum(arr2,axis=0))
    print('sum, 1', np.sum(arr2,axis=1))


.. code:: python

    print(np.prod(arr2))
    print(np.prod(arr2,axis=0))
    print(np.prod(arr2,axis=1))

.. code:: python

    print(arr2.mean(), '=', arr2.sum()/arr2.size)
    print(np.mean(arr2,axis=0))
    print(np.mean(arr2,axis=1))
    print(np.std(arr2))
    print(np.std(arr2,axis=1))


cumsum, cumprod, trapz
~~~~~~~~~~~~~~~~~~~~~~

Las funciones ``cumsum`` y ``cumprod`` devuelven la suma y producto
acumulativo recorriendo el array, opcionalmente a lo largo de un eje

.. code:: python

    print(arr2)

.. code:: python

    # Suma todos los elementos anteriores y devuelve el array unidimensional
    print(arr2.cumsum())

.. code:: python

    # Para cada columna, en cada posición suma los elementos anteriores
    print(arr2.cumsum(axis=0))

.. code:: python

    # En cada fila, el valor es la suma de todos los elementos anteriores de la fila
    print(arr2.cumsum(axis=1))

.. code:: python

    # Igual que antes pero con el producto
    print(arr2.cumprod(axis=0))

La función trapz evalúa la integral a lo largo de un eje, usando la
regla de los trapecios (la misma que nosotros programamos en un
ejercicio)

.. code:: python

    print(np.trapz(arr2,axis=0))
    print(np.trapz(arr2,axis=1))

.. code:: python

    # el valor por default de axis es -1
    print(np.trapz(arr2))

nonzero
~~~~~~~

Devuelve una *tupla* de arrays, una por dimensión, que contiene los
índices de los elementos no nulos

.. code:: python

    # El método copy() crea un nuevo array con los mismos valores que el original
    arr4 = arr2.copy()
    arr4[1,:2] = arr4[2,2:] = 0
    arr4

.. code:: python

    # Vemos que arr2 no se modifica al modificar arr4.
    arr2

.. code:: python

    np.nonzero(arr4)

.. code:: python

    np.transpose(arr4.nonzero())

.. code:: python

    arr4[arr4.nonzero()]

Conveniencias con arrays
------------------------

Convertir un array a unidimensional (ravel)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    a = np.array([[1,2],[3,4]])

.. code:: python

    print(a)

.. code:: python

    b= np.ravel(a)

.. code:: python

    print(a.shape, b.shape)
    print(b)

.. code:: python

    b.base  is a

``ravel`` tiene un argumento opcional ‘order’

.. code:: python

    np.ravel(a, order='C')          # order='C' es el default 

.. code:: python

    np.ravel(a, order='F')

El método ``flatten`` hace algo muy parecido a ``ravel``, la diferencia
es que ``flatten`` siempre crea una nueva copia del array, mientras que
``ravel`` puede devolver una nueva vista del mismo array.

.. code:: python

    a.flatten()

Enumerate para ``ndarrays``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Para iterables en **Python** existe la función enumerate que devuelve
una tupla con el índice y el valor. En **Numpy** existe un iterador
multidimensional llamado ``ndenumerate()``

.. code:: python

    print(arr2)

.. code:: python

    for (i,j), x in np.ndenumerate(arr2):
      print(f'x[{i},{j}]-> {x}')

Vectorización de funciones escalares
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Si bien en **Numpy** las funciones están vectorizadas, hay ocasiones en
que las funciones son el resultado de una simulación, optimización,
integración u otro cálculo complejo, y si bien la paralelización puede
ser trivial, el cálculo debe ser realizado para cada valor de algún
parámetro y no puede ser realizado directamente con un vector. Para ello
existe la función ``vectorize()``. Veamos un ejemplo, calculando la
función *coseno()* como la integral del *seno()*

.. code:: python

    def my_trapz(f, a, b):
      x = np.linspace(a,b,100)
      y = f(x)
      return ((y[1:]+y[:-1])*(x[1:]-x[:-1])).sum()/2

.. code:: python

    def mi_cos(t):
      return 1-my_trapz(np.sin, 0, t)

.. code:: python

    mi_cos(np.pi/4)

que se compara bastante bien con el valor esperado del coseno:

.. code:: python

    np.cos(np.pi/4)

Para calcular sobre un conjunto de datos:

.. code:: python

    x = np.linspace(0,np.pi,30)

.. code:: python

    print(mi_cos(x))

Obtuvimos un valor único que claramente no puede ser el coseno de ningún
ángulo. Si calculamos el coseno con el mismo argumento (vectorial)
obtenemos un vector de valores como se espera:

.. code:: python

    print(np.cos(x))

Si el cálculo fuera más complejo y no tuviéramos la posibilidad de
realizarlo en forma vectorial, debemos realizar una iteración llamando a
esta función en cada paso:

.. code:: python

    y = []
    for xx in x:
      y.append(mi_cos(xx))
    print(np.array(y))

.. code:: python

    y = np.zeros(x.size)
    for i,xx in enumerate(x):
      y[i] = mi_cos(xx)

.. code:: python

    plt.plot(x,y)

Como conveniencia, para evitar tener que hacer explícitamente el bucle
``for`` existe la función ``vectorize``, que toma como argumento a una
función que toma y devuelve escalares, y retorna una función equivalente
que acepta arrays:

.. code:: python

    coseno = np.vectorize(mi_cos)

.. code:: python

    plt.plot(x, coseno(x), '-')

--------------

Ejercicios 10 (a)
-----------------

1. Dado un array ``a`` de números, creado por ejemplo usando:

   .. code:: python

      a = np.random.uniform(size=100)

   Encontrar el número más cercano a un número escalar dado (por ejemplo
   x=0.5). Utilice los métodos discutidos.

--------------

.


