Clase 8: Introducción a Numpy 
===============================


Algunos ejemplos
----------------

Dos paquetes que van a resultar muy importantes para nosotros son los
paquetes **numpy** y **matplotlib**. Como con todos los módulos, se
cargan utilizando la palabra ``import``, tal como hicimos en los
ejemplos anteriores. Existen variantes en la manera de importar los
módulos que son “equivalentes”. En este caso le vamos a dar un alias que
sea más corto de tipear. Después podemos utilizar sus funciones y
definiciones.

Graficación de datos de archivos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt

.. code:: python

    x, y = np.loadtxt('../data/ejemplo_plot_07_1.dat', unpack=True)
    plt.plot(x, y)

Como vemos es muy simple cargar datos de un archivo y graficarlos.
Veamos qué datos hay en el archivo:

.. code:: python

    !head ../data/ejemplo_plot_07_1.dat

Hay dos columnas, en la primera fila hay texto, y en las siguientes hay
valores separados por un espacio. En la primera línea, la función
``np.loadtxt()`` carga estos valores a las variables ``x`` e ``y``, y en
la segunda los graficamos. Inspeccionemos las variables

.. code:: python

    len(x)

.. code:: python

    x[:10]

.. code:: python

    type(x), type(y)

Como vemos, el tipo de la variable **no es una lista** sino un nuevo
tipo: **ndarray**, o simplemente **array**. Veamos cómo trabajar con
ellos.

Comparación de listas y *arrays*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Comparemos como operamos sobre un conjunto de números cuando los
representamos por una lista, o por un array:

.. code:: python

    dlist = [1.5, 3.8, 4.9, 12.3, 27.2, 35.8, 70.2, 90., 125., 180.]

.. code:: python

    d = np.array(dlist)

.. code:: python

    d is dlist

.. code:: python

    print(dlist)

.. code:: python

    print(d)

Veamos cómo se hace para operar con estos dos tipos. Si los valores
representan ángulos en grados, hagamos la conversión a radianes (radián
= :math:`\pi/180` grado)

.. code:: python

    from math import pi
    drlist= [a*pi/180 for a in dlist]

.. code:: python

    print(drlist)

.. code:: python

    dr= d*(np.pi/180)

.. code:: python

    print(dr)

Vemos que el modo de trabajar es más simple ya que los array permiten
trabajar con operaciones elemento-a-elemento mientras que para las
listas tenemos que usar comprensiones de listas. Veamos otros ejemplos:

.. code:: python

    print([np.sin(a*pi/180) for a in dlist])

.. code:: python

    print(np.sin(np.deg2rad(d)))

Además de la simplicidad para trabajar con operaciones que actúan sobre
cada elemento, el paquete tiene una gran cantidad de funciones y
constantes definidas (como por ejemplo ``np.pi`` para :math:`\pi`).

.. code:: python

    plt.plot(d, np.sin(np.deg2rad(d)),'o-')
    plt.show()

Generación de datos equiespaciados
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Para obtener datos equiespaciados hay dos funciones complementarias

.. code:: python

    a1 = np.arange(0,190,10)
    a2 = np.linspace(0,180,19)

.. code:: python

    a1

.. code:: python

    a2

Como vemos, ambos pueden dar resultados similares, y es una cuestión de
conveniencia cual utilizar. El uso es:

.. code:: python

   np.arange([start,] stop[, step,], dtype=None)

   np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

Mientras que a ``arange()`` le decimos cuál es el paso a utilizar, a
``linspace()`` debemos (podemos) darle como tercer argumento el número
de valores que queremos.

.. code:: python

    plt.plot(a2, np.sin(np.deg2rad(a2)),'o-')
    plt.show()

.. code:: python

    # Pedimos que devuelva el paso también
    v1, step1 = np.linspace(0,10,20, endpoint=True, retstep=True)
    v2, step2 = np.linspace(0,10,20, endpoint=False, retstep=True)

.. code:: python

    print(step1)
    print(step2)

Además de valores linealmente espaciados podemos obtener valores
espaciados en escala logarítmica

.. code:: python

    w= np.logspace(0,10,20)

.. code:: python

    plt.plot(v1, w, 'o-')
    plt.show()

Características de *arrays* en **Numpy**
----------------------------------------

Numpy define unas nuevas estructuras llamadas *ndarrays* o *arrays* para
trabajar con vectores de datos, en una dimensión o más dimensiones
(“matrices”). Los arrays son variantes de las listas de python
preparadas para trabajar a mayor velocidad y menor consumo de memoria.
Por ello se requiere que los arrays sean menos generales y versátiles
que las listas usuales. Analicemos brevemente las diferencias entre
estos tipos y las consecuencias que tendrá en su uso para nosotros.

Uso de memoria de listas y arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Las listas son sucesiones de elementos, completamente generales y no
necesariamente todos iguales. Un esquema de su representación interna se
muestra en el siguiente gráfico para una lista de números enteros (Las
figuras y el análisis de esta sección son de
www.python-course.eu/numpy.php)

.. figure:: figuras/list_structure.png
   :alt: Representación en memoria de una lista

   Representación en memoria de una lista

Básicamente en una lista se guarda información común a cualquier lista,
un lugar de almacenamiento que referencia donde buscar cada uno de sus
elementos (que puede ser un objeto diferente) y luego el lugar efectivo
para guardar cada elemento. Veamos cuanta memoria se necesita para
guardar una lista de enteros:

.. code:: python

    from sys import getsizeof
    lst = [24, 12, 57]
    size_of_list_object = getsizeof(lst)   # only green box
    #size_of_elements = getsizeof(lst[0]) + getsizeof(lst[1]) + getsizeof(lst[2])
    size_of_elements = sum(getsizeof(l) for l in lst)
    total_list_size = size_of_list_object + size_of_elements
    print("Tamaño sin considerar los elementos: ", size_of_list_object)
    print("Tamaño de los elementos: ", size_of_elements)
    print("Tamaño total: ", total_list_size)

Para calcular cuánta memoria se usa en cada parte de una lista
analicemos el tamaño de distintos casos:

.. code:: python

    print('Una lista vacía ocupa: {} bytes'.format(getsizeof([])))
    print('Una lista con un elem: {} bytes'.format(getsizeof([24])))
    print('Una lista con 2 elems: {} bytes'.format(getsizeof([24,12])))
    print('Un entero en Python  : {} bytes'.format(getsizeof(24)))

Vemos que la “Información general de listas” ocupa **64 bytes**, y la
referencia a cada elemento entero ocupa adicionalmente **8 bytes**.
Además, cada elemento, un entero de Python, en este caso ocupa **28
bytes**, por lo que el tamaño total de una **lista** de :math:`n`
números enteros será:

.. math::   M_{L}(n) = 64 + n \times 8 + n \times 28 

En contraste, los *arrays* deben ser todos del mismo tipo por lo que su
representación es más simple (por ejemplo, no es necesario guardar sus
valores separadamente)

.. figure:: figuras/array_structure.png
   :alt: Representación en memoria de una lista

   Representación en memoria de una lista

.. code:: python

    a = np.array(lst)
    print(getsizeof(a))

Para analizar como se distribuye el consumo de memoria en un array vamos
a calcular el tamaño de cada uno de los elementos como hicimos con las
listas:

.. code:: python

    print('Un array vacío ocupa: {} bytes'.format(getsizeof(np.array([]))))
    print('Un array con un elem: {} bytes'.format(getsizeof(np.array([24]))))
    print('Un array con 2 elems: {} bytes'.format(getsizeof(np.array([24,12]))))
    print('Un entero de Numpy es: {}'.format(type(a[0])))

Vemos que la información general sobre arrays ocupa **96 bytes** (en
contraste a **64** para listas), y por cada elemento otros **8 bytes**
adicionales (``numpy.int64`` corresponde a 64 bits), por lo que el
tamaño total será:

.. math::   M_{a}(n) = 96 + n \times 8 

.. code:: python

    from sys import getsizeof
    lst1 = list(range(1000))
    total_list_size = getsizeof(lst1) + sum(getsizeof(l) for l in lst1)
    print("Tamaño total de la lista: ", total_list_size)
    a1 = np.array(lst1)
    print("Tamaño total de array: ", getsizeof(a1))

Velocidad de **Numpy**
~~~~~~~~~~~~~~~~~~~~~~

Una de las grandes ventajas de usar *Numpy* está relacionada con la
velocidad de cálculo. Veamos (superficialmente) esto

.. code:: python

    %load scripts/timing.py

.. code:: python

    # %load scripts/timing.py
    # Ejemplo del libro en www.python-course.eu/numpy.php
    
    import numpy as np
    from timeit import Timer
    Ndim = 10000
    
    
    def pure_python_version():
      X = range(Ndim)
      Y = range(Ndim)
      Z = []
      for i in range(len(X)):
        Z.append(X[i] + Y[i])
      return Z
    
    
    def numpy_version():
      X = np.arange(Ndim)
      Y = np.arange(Ndim)
      Z = X + Y
      return Z
    
    timer_obj1 = Timer("pure_python_version()", "from __main__ import pure_python_version")
    timer_obj2 = Timer("numpy_version()", "from __main__ import numpy_version")
    t1 = timer_obj1.timeit(10)
    t2 = timer_obj2.timeit(10)
    
    print("Numpy es en este ejemplo {:.3f} más rápido".format(t1 / t2))


.. code:: python

    # %load scripts/timing.py
    # Ejemplo del libro en www.python-course.eu/numpy.php
    
    import numpy as np
    from timeit import Timer
    Ndim = 10000
    
    
    def pure_python_version():
      X = range(Ndim)
      Y = range(Ndim)
      Z = []
      for i in range(len(X)):
        Z.append(X[i] + Y[i])
      return Z
    
    
    def numpy_version():
      X = np.arange(Ndim)
      Y = np.arange(Ndim)
      Z = X + Y
      return Z
    
    timer_obj1 = Timer("pure_python_version()", "from __main__ import pure_python_version")
    timer_obj2 = Timer("numpy_version()", "from __main__ import numpy_version")
    t1 = timer_obj1.timeit(10)
    t2 = timer_obj2.timeit(10)
    
    print("Numpy es en este ejemplo {:.3f} más rápido".format(t1 / t2))


Como vemos, utilizar *Numpy* puede ser considerablemente más rápido que
usar *Python puro*.

Creación de *arrays* en **Numpy**
---------------------------------

Un ``array`` en numpy es un tipo de variable parecido a una lista, pero
está optimizado para realizar trabajo numérico.

Todos los elementos deben ser del mismo tipo, y además de los valores,
contiene información sobre su tipo. Veamos algunos ejemplos de cómo
crearlos y utilizarlos:

Creación de *Arrays* unidimensionales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    i1 = np.array([1, 2, 3, 1, 5, 1, 9, 22, 0])
    r1 = np.array([1.4 ,2.3 ,3.0 ,1, 5, 1, 9, 22, 0])

.. code:: python

    print(i1)
    print(r1)

.. code:: python

    print('tipo de i1: {} \ntipo de r1: {}'.format(i1.dtype, r1.dtype))

.. code:: python

    print('Para i1:\n  Número de dimensiones: {}\n  Longitud: {}'.format(np.ndim(i1), len(i1)))

.. code:: python

    print('Para r1:\n  Número de dimensiones: {}\n  Longitud: {}'.format(np.ndim(r1), len(r1)))

Arrays multidimensionales
~~~~~~~~~~~~~~~~~~~~~~~~~

Podemos crear explícitamente *arrays* multidimensionales con la función
``np.array`` si el argumento es una lista anidada

.. code:: python

    L = [ [1, 2, 3], [.2, -.2, -1], [-1, 2, 9], [0, 0.5, 0] ]
    
    A = np.array(L)

.. code:: python

    A

.. code:: python

    print(A)

.. code:: python

    print(A.ndim)

.. code:: python

    print(len(A))

Vemos que la dimensión de ``A`` es 2, pero la longitud que me reporta
**Python** corresponde al primer eje. Los *arrays* tienen un atributo
que es la “forma” (shape)

.. code:: python

    print(A.shape)

Otras formas de creación
~~~~~~~~~~~~~~~~~~~~~~~~

Hay otras maneras de crear **numpy arrays**. Algunas, de las más comunes
es cuando necesitamos crear un array con todos ceros o unos o algún
valor dado

.. code:: python

    a= np.zeros(5)

.. code:: python

    a.dtype                         # El tipo default es float de 64 bits

.. code:: python

    i= np.zeros(5, dtype=int)

.. code:: python

    print(i)

.. code:: python

    i.dtype

.. code:: python

    c= np.zeros(5,dtype=complex)
    print(c)
    print(c.dtype)

En lugar de inicializarlo en cero podemos inicializarlo con algún valor

.. code:: python

    np.ones(5, dtype=complex) + 1j      # Algo similar pero inicializando a unos

Ya vimos que también podemos inicializarlos con valores “equiespaciados”
con ``np.arange()``, con ``np.linspace()`` o con ``np.logspace()``

.. code:: python

    v = np.arange(2,15,2) # Crea un array con una secuencia (similar a la función range)

Para crear *arrays* multidimensionales usamos:

.. code:: python

    np.ones((4,5))

.. code:: python

    np.ones((4,3,6))

.. code:: python

    np.eye(4)

.. code:: python

    np.eye(3,7)

En este último ejemplo hemos creado matrices con unos en la diagonal y
ceros en todos los demás lugares.

Acceso a los elementos
----------------------

El acceso a los elementos tiene una forma muy parecida a la de las
listas (pero no exactamente igual).

.. code:: python

    print(r1)

Si queremos uno de los elementos usamos la notación:

.. code:: python

    print(r1[0], r1[3], r1[-1])

y para “tajadas” (*slices*)

.. code:: python

    print(r1[:3])

.. code:: python

    print(r1[-3:])

.. code:: python

    print(r1[5:7])

.. code:: python

    print(r1[0:8:2])

Como con vectores unidimensionales, con arrays multidimensionales, se
puede ubicar un elemento o usar *slices*:

.. code:: python

    arr = np.arange(55).reshape((5,11))

.. code:: python

    arr

.. code:: python

    print( 'Slicing parte de la segunda fila :', arr[1, 2:4])
    print('Todas las filas, tercera columna :', arr[:, 2])

.. code:: python

    print( 'Primera fila   :\n', arr[0], '\nes igual a :\n', arr[0,:])

.. code:: python

    print( 'Segunda fila   :\n', arr[1], '\nes igual a :\n', arr[1,:])

.. code:: python

    print( 'Primera columna:', arr[:,0])

.. code:: python

    print( 'Última columna : \n', arr[:,-1])

.. code:: python

    print( 'Segunda fila, elementos pares (0,2,...) : ', arr[1,::2])

.. code:: python

    print( 'Segunda fila, todos los elementos impares : ', arr[1,1::2])

Cuando el *slicing* se hace de la forma ``[i:f:s]`` significa que
tomaremos los elementos entre ``i`` (inicial), hasta ``f`` (final, no
incluido), pero tomando sólo uno de cada ``s`` (stride) elementos

|image0|

En `Scipy Lectures at
http://scipy-lectures.github.io <http://scipy-lectures.github.io>`__ hay
una descripción del acceso a arrays.

.. |image0| image:: figuras/numpy_indexing.png

Ejercicios 08 (a)
-----------------

1. Genere dos arrays en 2d, cada uno de tamaño 10x10 con:
2. Un array con valores 1 en la “diagonal principal” y 0 en el resto
   (Matriz identidad).
3. Un array con valores 0 en la “diagonal principal” y 1 en el resto
   (Matriz identidad).
4. Un array con valores 1 en los bordes y 0 en el interior.
5. Un array con números enteros consecutivos (empezando en 1) en los
   bordes y 0 en el interior.

6. Diga qué resultado produce el siguiente código, y explíquelo

.. code:: python

   # Ejemplo propuesto por Jake VanderPlas
   print(sum(range(5),-1))
   from numpy import *
   print(sum(range(5),-1))

Propiedades de **Numpy** arrays
-------------------------------

Propiedades básicas
~~~~~~~~~~~~~~~~~~~

Hay tres propiedades básicas que caracterizan a un array:

-  ``shape``: Contiene información sobre la forma que tiene un array
   (sus dimensiones: vector, matriz, o tensor)
-  ``dtype``: Es el tipo de cada uno de sus elementos (todos son
   iguales)
-  ``stride``: Contiene la información sobre como recorrer el array. Por
   ejemplo si es una matriz, tiene la información de cuántos bytes en
   memoria hay que pasar para pasar de una fila a la siguiente y de una
   columna a la siguiente.

.. code:: python

    arr = np.arange(55).reshape((5,11))

.. code:: python

    print( 'shape  :', arr.shape)
    print( 'dtype  :', arr.dtype)
    print( 'strides:', arr.strides)

.. code:: python

    print(np.arange(55).shape)
    print(arr.shape)

Otras propiedades y métodos de los *array*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Los array tienen atributos que nos dan información sobre sus
características:

.. code:: python

    print( 'Número total de elementos :', arr.size)
    print( 'Número de dimensiones     :', arr.ndim)
    print( 'Memoria usada             : {} bytes'.format( arr.nbytes))

Además, tienen métodos que facilitan algunos cálculos comunes. Veamos
algunos de ellos:

.. code:: python

    print( 'Mínimo y máximo                  :', arr.min(), arr.max())
    print( 'Suma y producto de sus elementos :', arr.sum(), arr.prod())
    print( 'Media y desviación standard      :', arr.mean(), arr.std())

Para todos estos métodos, las operaciones se realizan sobre todos los
elementos. En array multidimensionales uno puede elegir realizar los
cálculos sólo sobre un dado eje:

.. code:: python

    print( 'Para el array:\n', arr)

.. code:: python

    print( 'La suma de todos los elementos es    :', arr.sum())

.. code:: python

    print( 'La suma de elementos de las filas es :', arr.sum(axis=1))

.. code:: python

    print( 'La suma de elementos de las columnas es :', arr.sum(axis=0))

Operaciones sobre arrays
------------------------

Operaciones básicas
~~~~~~~~~~~~~~~~~~~

Los array se pueden usar en operaciones:

.. code:: python

    # Suma de una constante
    arr1 = 1 + arr[:,::-1]              # Creamos un segundo array

.. code:: python

    arr1

.. code:: python

    # Multiplicación por constantes y suma de arrays
    2* arr + 3*arr1

.. code:: python

    # División por constantes
    arr/5

.. code:: python

    # Multiplicación entre arrays
    arr * arr1

.. code:: python

    arr / arr1

Como vemos, están definidas todas las operaciones por constantes y entre
arrays. En operaciones con constantes, se aplican sobre cada elemento
del array. En operaciones entre arrays se realizan elemento a elemento
(y el número de elementos de los dos array debe ser compatible).

Comparaciones
~~~~~~~~~~~~~

También se pueden comparar dos arrays elemento a elemento

.. code:: python

    v = np.linspace(0,19,20)
    w = np.linspace(0.5,18,20)

.. code:: python

    print (v)
    print (w)

.. code:: python

    # Comparación de un array con una constante
    print(v > 12)

.. code:: python

    # Comparación de un array con una constante
    print(v > w)

Funciones definidas en **Numpy**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Algunas de las funciones definidas en numpy se aplican a cada elemento.
Por ejemplo, las funciones matemáticas:

.. code:: python

    np.sin(arr1)

.. code:: python

    np.exp(-arr**2/2)

.. code:: python

    v[w > 9]

También podemos hacer todo tipo de operaciones (suma, resta,
multiplicación,….) entre *arrays*

Ejercicios 08 (b)
-----------------

3. Escriba una función ``suma_potencias(p, n)`` (utilizando arrays y
   **Numpy**) que calcule la operación

   .. math:: s_{2} = \sum_{k=0}^{n}k^{p}

   .

4. Usando las funciones de numpy ``sign`` y ``maximum`` definir las
   funciones:

-  función de Heaviside, que vale 1 para valores positivos de su
   argumento y 0 para valores negativos.
-  La función escalón, que vale 0 para valores del argumento fuera del
   intervalo :math:`(-1,1)` y 1 para argumentos en el intervalo.
-  La función rampa, que vale 0 para valores negativos de :math:`x` y
   :math:`x` para valores positivos.

Lectura y escritura de datos a archivos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Numpy tiene funciones que permiten escribir y leer datos de varias
maneras, tanto en formato *texto* como en *binario*. En general el modo
*texto* ocupa más espacio pero puede ser leído y modificado con un
editor.

Datos en formato texto
^^^^^^^^^^^^^^^^^^^^^^

.. code:: python

    np.savetxt('test.out', arr, fmt='%.2e', header="x    y   \n z    z2", comments="% ")
    !cat test.out

.. code:: python

    arr2 = np.loadtxt('test.out', comments="%")
    print(arr2)

.. code:: python

    print(arr2.shape)
    print(arr2.ndim)
    print(arr2.size)

Ejercicios 08 (c)
-----------------

5. **PARA ENTREGAR. Caída libre** Cree un programa que calcule la
   posición y velocidad de una partícula en caída libre para condiciones
   iniciales dadas (:math:`h_{0}`, :math:`v_{0}`), y un valor de
   gravedad dados. Se utilizará la convención de que alturas y
   velocidades positivas corresponden a vectores apuntando hacia arriba
   (una velocidad positiva significa que la partícula se aleja de la
   tierra).

El programa debe realizar el cálculo de la velocidad y altura para un
conjunto de tiempos equiespaciados. El usuario debe poder decidir o
modificar el comportamiento del programa mediante opciones por línea de
comandos.

El programa debe aceptar las siguientes opciones por líneas de comando:
- ``-v vel`` o, equivalentemente ``--velocidad=vel``, donde ``vel`` es
el número dando la velocidad inicial en m/s. El valor por defecto será
``0``. - ``-h alt`` o, equivalentemente ``--altura=alt``, donde ``alt``
es un número dando la altura inicial en metros. El valor por defecto
será ``1000``. La altura inicial debe ser un número positivo. -
``-g grav``, donde ``grav`` es el módulo del valor de la aceleración de
la gravedad en :math:`m/s^2`. El valor por defecto será ``9.8``. -
``-o nombre`` o, equivalentemente ``--output=nombre``, donde ``nombre``
será el nombre de un archivo donde se escribirán los resultados. Si el
usuario no usa esta opción, debe imprimir por pantalla (``sys.stdout``).
- ``-n N`` o, equivalentemente ``--Ndatos=N``, donde ``N`` es un número
entero indicando la cantidad de datos que deben calcularse. Valor por
defecto: ``100`` - ``--ti=instante_inicial`` indica el tiempo inicial de
cálculo. Valor por defecto: ``0``. No puede ser mayor que el tiempo de
llegada a la posición :math:`h=0` - ``--tf=tiempo_final`` indica el
tiempo inicial de cálculo. Valor por defecto será el correspondiente al
tiempo de llegada a la posición :math:`h=0`.

**NOTA:** Envíe el programa llamado **Suapellido_08.py** en un adjunto
por correo electrónico, con asunto: **Suapellido_08**, antes del día
lunes 9 de Marzo.

6. Queremos realizar numéricamente la integral

   .. math::


        \int_{a}^{b}f(x)dx
        

   utilizando el método de los trapecios. Para eso partimos el intervalo
   :math:`[a,b]` en :math:`N` subintervalos y aproximamos la curva en
   cada subintervalo por una recta

|image0|

La línea azul representa la función :math:`f(x)` y la línea roja la
interpolación por una recta (figura de
https://en.wikipedia.org/wiki/Trapezoidal_rule)

Si llamamos :math:`x_{i}` (:math:`i=0,\ldots,n,` con :math:`x_{0}=a` y
:math:`x_{n}=b`) los puntos equiespaciados, entonces queda

.. math::


        \int_{a}^{b}f(x)dx\approx\frac{h}{2}\sum_{i=1}^{n}\left(f(x_{i})+f(x_{i-1})\right).
     

-  Escriba una función ``trapz(x, y)`` que reciba dos arrays
   unidimensionales ``x`` e ``y`` y aplique la fórmula de los trapecios.

-  Escriba una función ``trapzf(f, a, b, npts=100)`` que recibe una
   función ``f``, los límites ``a``, ``b`` y el número de puntos a
   utilizar ``npts``, y devuelve el valor de la integral por trapecios.

-  Calcule la integral logarítmica de Euler:

   .. math:: \mathrm{Li}(t) = \int_2^t \frac{1}{\ln x} dx

   usando la función ´trapzf´ para valores de
   ``npts=10, 20, 30, 40, 50, 60``

.. |image0| image:: figuras/trapez_rule_wiki.png


