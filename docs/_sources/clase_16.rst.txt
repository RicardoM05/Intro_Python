.. _clase_16:

Clase 16: Programaci√≥n funcional con Python
============================================


La programaci√≥n funcional es un paradigma de programaci√≥n, de la misma
manera que otros paradigmas, como la programaci√≥n orientada a objetos, o
la programaci√≥n estructurada.

Existen lenguajes de programaci√≥n que son directamente funcionales, esto
es, implementan las reglas de la programaci√≥n funcional directamente
(por ejemplo, Lisp, Haskell, F#, etc.). Desde un punto de vista
hist√≥rico, la programaci√≥n funcional tiene su origen en la visi√≥n de
Alonzo Church del problema de la decisi√≥n (*Entscheidungsproblem*), y es
complementaria a la m√°s conocida, propuesta por Alan Turing.

Python es un lenguaje orientado a objetos (todo elemento del lenguaje es
un objeto), de modo tal que no es posible hablar de un paradigma
funcional en Python, sino mas bien de un *estilo* de programaci√≥n
funcional.

Un trabajo interesante es el siguiente: ‚ÄôWhy Functional Programming
Matters: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf‚Äù.

Los errores al programar
------------------------

En el continuo devenir de la programaci√≥n, uno se encuentra,
principalmente, resolviendo errores. Un resumen de los errores posibles
en un c√≥digo se pueden encontrar en la expresi√≥n

   ``i = i+1``

En esta expresi√≥n podemos encontrar tres tipos de errores:

-  *Error de lectura* : el valor de ``i`` en el lado derecho no es el
   que efectivamente uno desear√≠a, es decir, el c√≥digo est√° leyendo un
   valor incorrecto.

-  *Error de escritura* : el valor de ``i`` en el lado izquierdo no es
   el que efectivamente uno desear√≠a, es decir, estamos guardando la
   expresi√≥n en una variable incorrecta.

-  *Error de c√≥mputo* : que se produce, por ejemplo, porque no queremos
   sumar 1 sino 2, o queremos restar el valor de i.

Existe un cuarto tipo de error que aparece y tiene que ver con un *error
de flujo*, en el cual el c√≥digo se ejecuta en una rama que no es la
deseada, debido a que una condici√≥n l√≥gica no se cumple tal como se
esperaba. O por ejemplo, el orden en que se ejecutan las sentencias no
es el adecuado:

.. code:: python

    # Funci√≥n que calcula (x+1)(x+2)
    def f(x):
        x = x+1 
        y = x+1
        return x*y

.. code:: python

    # Funci√≥n que calcula (x+1)(x+2) ?? Mmmm.....
    def g(x):
        y = x+1
        x = x+1 
        return x*y

.. code:: python

    print(f(3))
    print(g(3))


.. parsed-literal::

    20
    16


Los errores en notebooks
------------------------

Adem√°s de las complejidades propias de la programaci√≥n, que est√°n
asociadas al *dominio* donde se encuentra el problema que uno quiere
resolver, y a las dificultades que eso implica; los *notebooks*
introducen tambi√©n una dificultad adicional: uno puede redefinir los
datos en celdas posteriores, pero puede volver ‚Äòatr√°s‚Äô en el c√≥digo y
recalcular otra celda. Veamos un
`ejemplo <https://verve.com/blog/jupyter-notebooks/>`__:

.. code:: python

    data = [1,2,3,4]

.. code:: python

    def prom(a):
        s = sum(a)
        n = len(a)
        return s/n

.. code:: python

    prom(data)




.. parsed-literal::

    2.5



.. figure:: https://assets-global.website-files.com/5f3c19f18169b62a0d0bf387/60d33beacf4ba7263a23cd79_qh6ImC4NPdyPbvn-7ns8FYsgOskDPDWLnX31mLCOgSwpX_SQgmo8krqdg4e6XAnSbqRAtZMYqlf7UTvlHiXgt5YtMwbt9IRY1fAbOjyq5hARui-xEQUgI48EOjhJGuIsSFDg90L6.jpeg
   :alt: M√°s c√≥digo

   M√°s c√≥digo

.. code:: python

    data = "Some data"
    print(len(data))


.. parsed-literal::

    9


Mutabilidad
-----------

Los problemas que vemos arriba se deben a la *mutabilidad*: las
*variables* pueden cambiar (esto es, ser reescritas) a lo largo del
c√≥digo. Ahora bien, pareciera que la mutabilidad es intr√≠nseca a la
computaci√≥n, al fin y al cabo, en el hardware hay una cantidad limitada
de memoria y de registros que son continuamente reescritos para que
nuestro c√≥digo corra. Sin embargo, los lenguajes de programaci√≥n de alto
nivel que usamos nos alejan (afortunadamente) del requerimiento de
mantener el estado de la memoria y los registros expl√≠citamente en el
c√≥digo (y en el algoritmo en nuestra cabeza).

La pregunta que cabe entonces es ¬øc√≥mo hacer un c√≥digo que prevenga la
mutabilidad, pero que a la vez me permita transformar los datos para
resolver mi problema? La respuesta viene de la mano de un ente muy
conocido en m√°tem√°ticas: *las funciones*

Funciones
---------

Una funci√≥n desde el punto de vista matem√°tico es una relaci√≥n que a
cada elemento de un conjunto le asocia exactamente un elemento de otro
conjunto. Estos conjuntos pueden ser n√∫meros, vectores, matrices en el
mundo matem√°tico,

.. raw:: html

   <h3>

.. raw:: html

   <center>

:math:`y = f(x)`

.. raw:: html

   </center>

.. raw:: html

   </h3>

o, en un mundo m√°s f√≠sico, peras, manzanas, nombres, apellidos, `objetos
varios <https://commons.wikimedia.org/w/index.php?curid=20802095>`__:

.. figure:: figuras/Function_color_example_3.png
   :alt: una funcion

   una funcion

Estas funciones tienen dos caracter√≠sticas fundamentales para usar en
programaci√≥n: - Permiten ‚Äútransformar‚Äù un valor en otro - El valor
original **no** se modifica

Es decir que el uso de funciones, al estilo matem√°tico, en un c√≥digo
resuelven el problema de la mutabilidad, pero a la vez me permiten
‚Äútransformar‚Äù, es decir, crear nuevos valores a partir del valor
original.

Funciones puras
~~~~~~~~~~~~~~~

El an√°logo computacional de las funciones matem√°ticas se llaman
*funciones puras*. Una funci√≥n se dice pura cuando: - Siempre retorna el
mismo valor de salida para el mismo valor de entrada - No tiene efectos
colaterales (*side effects*)

.. figure:: figuras/afunction.png
   :alt: una funcion

   una funcion

Funciones de primer orden o primera clase
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Un lenguaje se dice que tiene funciones de primera clase cuando son
tratadas exactamente igual que otros valores o variables.

Funciones de orden superior
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Un lenguaje que permite pasar funciones como argumentos se dice que
acepta funciones de orden superior.

.. code:: python

    def square(x):
        return x*x

.. code:: python

    def next(x):
        return x+1 

.. code:: python

    a = 4
    b = next(a)
    c = next(next(a))

.. code:: python

    print(a)
    print(b)
    print(c)


.. parsed-literal::

    4
    5
    6


.. code:: python

    def h(x):
        return (next(x))*(next(next(x)))

.. code:: python

    print(h(3))


.. parsed-literal::

    20


Si se tiene funciones puras, es posible componerlas

.. code:: python

    def compose(f, g):
        return lambda x: f(g(x))

.. code:: python

    next2 = compose(next,next)

.. code:: python

    print(next2(a))


.. parsed-literal::

    6


Inmutabilidad
-------------

Usando funciones puras se garantiza la inmutabilidad de los valores
hacia adentro de la funci√≥n. Pero, ¬øqu√© sucede afuera? Python, al no ser
un lenguaje funcional *per se*, no tiene la capacidad de establecer la
inmutabilidad de cualquier valor, excepto para los casos de strings y
tuplas, adem√°s, obviamente, de las expresiones literales.

**Queda entonces en el programador la responsabilidad de no mutar los
datos‚Ä¶**

**‚Ä¶ o usar anotaciones de tipos**

.. code:: python

    def cube(x: int) -> int:
        return x*x*x

.. code:: python

    print(cube(2))


.. parsed-literal::

    8


N√≥tese que Python NO chequea los tipos de datos, no tiene manera en
forma nativa de hacerlo. Por eso puedo ejecutar la funci√≥n ``cube`` con
floats, por ejemplo:

.. code:: python

    print(cube(3.0))


.. parsed-literal::

    27.0


Para poder utilizar la anotaci√≥n de tipos en forma efectiva, se puede
recurrir a ```mypy`` <http://mypy-lang.org/index.html>`__. Esta es una
aplicaci√≥n que me permite comprobar tipos de datos anotados en Python.
Para instalar ``mypy`` usamos:

``conda install mypy``

.. code:: python

    cd mypy_example


.. parsed-literal::

    /Users/flavioc/Library/Mobile Documents/com~apple~CloudDocs/Documents/cursos/curso-python/mypy_example


.. code:: python

    !cat cube.py


.. parsed-literal::

    def cube(x: int) -> int:
    	return x*x*x
    
    def Hola(name: str) -> str:
        return 'Hola ' + name	
    
    def Hola2(name):
        return 'Hola ' + name	
    
    
    
    
    if __name__ == "__main__":
    	
    	a = cube(2)
    
    	print(a)
    
    	b = cube(3.0)   # Esto no da error en Python, mypy si lo captura
    
    	print(b)
    
    	print(Hola('Juan'))
    	print(Hola2(3)) # Esto da un error de concatenaci√≥n
    
    	print(Hola(3)) # Esto da un error de concatenaci√≥n, y adem√°s mypy lo captura
    	

.. code:: python

    !python3 cube.py


.. parsed-literal::

    8
    27.0
    Hola Juan
    Traceback (most recent call last):
      File "/Users/flavioc/Library/Mobile Documents/com~apple~CloudDocs/Documents/cursos/curso-python/mypy_example/cube.py", line 24, in <module>
        print(Hola2(3)) # Esto da un error de concatenaci√≥n
      File "/Users/flavioc/Library/Mobile Documents/com~apple~CloudDocs/Documents/cursos/curso-python/mypy_example/cube.py", line 8, in Hola2
        return 'Hola ' + name	
    TypeError: can only concatenate str (not "int") to str


.. code:: python

    !mypy cube.py


.. parsed-literal::

    cube.py:19: [1m[31merror:[m Argument 1 to [m[1m"cube"[m has incompatible type [m[1m"float"[m; expected [m[1m"int"[m[m
    cube.py:26: [1m[31merror:[m Argument 1 to [m[1m"Hola"[m has incompatible type [m[1m"int"[m; expected [m[1m"str"[m[m
    [1m[31mFound 2 errors in 1 file (checked 1 source file)[m


Es posible que uno quiera usar ``mypy`` sobre un archivo de notebook
``ipynb``. Para eso hay que instalar la aplicaci√≥n ``nbQA`` `m√°s
detalles ac√° <https://github.com/nbQA-dev/nbQA>`__.

No m√°s loops
------------

Si las funciones deben ser puras, y las ‚Äòvariables‚Äô dejan de ser
variables y pasan a ser valores, entonces no puede haber loops en mi
c√≥digo. Un loop necesita invariablemente un contador (``i = i+1``) que
necesariamente es una variable mutable. As√≠ que as√≠ nom√°s, de un plumazo
no existen m√°s loops.

¬øEntonces? Entonces, todos los loops se reemplazan por llamados a
funciones recursivas, o se utilizan funciones de orden superior:

.. code:: python

    # Filter 
    
    l = [1,2,3,4,5,6]
    
    def es_par(x):
        return (x%2 == 0)
    
    pares = list(filter(es_par,l))
    print(pares)



.. parsed-literal::

    [2, 4, 6]


.. code:: python

    # Filter usando list comprehension
    list(x for x in l if es_par(x))




.. parsed-literal::

    [2, 4, 6]



.. code:: python

    # Map
    siguientes = list(map(next,l))
    print(siguientes)


.. parsed-literal::

    [2, 3, 4, 5, 6, 7]


El m√≥dulo ``functools`` provee la funci√≥n ``reduce``, que complementa a
``map`` y ``filter``.

.. code:: python

    # Reduce
    from functools import *
    import operator
    
    # Suma usando el predicado desde el m√≥dulo `operator`
    suma = reduce(operator.add,l,0)
    print(suma)
    



.. parsed-literal::

    21


.. code:: python

    help(reduce)


.. parsed-literal::

    Help on built-in function reduce in module _functools:
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.
    


.. code:: python

    # Suma usando el predicado como lambda
    otra_suma = reduce(lambda x,y: x+y, l)
    print(otra_suma)


.. parsed-literal::

    21


.. code:: python

    # Suma definiendo la propia funci√≥n suma
    def add(x,y):
        return x+y
    
    y_otra_suma = reduce(add,l)
    print(y_otra_suma)


.. parsed-literal::

    21


La suma de los cuadrados de una lista:

.. code:: python

    suma_cuadrados = reduce(lambda x,y: x+y, map(square,l))
    print(suma_cuadrados)


.. parsed-literal::

    91


--------------

Ejercicios 16
-------------

1. Construya una funci√≥n ``partition(lst,predicate)`` que dada una lista
   ``lst`` y una funci√≥n ``predicate``, separe la lista ``lst`` en dos:
   una lista que contiene los valores para los cuales la funci√≥n
   ``predicate`` devuelve ``True``, y otra lista que contiene los
   valores para los que ``predicate`` devuelve ``False``:

   .. code:: python

      def is_even(x):
          return x % 2 == 0

      numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      evens, odds = divide_list(numbers, is_even)

      print(evens) # Output: [2, 4, 6, 8, 10]
      print(odds)  # Output: [1, 3, 5, 7, 9]

2. Dado la cadena de caracteres

   .. code:: python

      s1='En un lugar de la Mancha de cuyo nombre no quiero acordarme'

   Utilice ``reduce``, ``map`` y/o ``filter`` (y las funciones
   auxiliares necesarias) para:

   -  Obtener la cantidad de caracteres.
   -  Imprimir la frase anterior pero con cada palabra empezando en
      may√∫sculas.
   -  Contar cuantas letras ‚Äòa‚Äô tiene la frase.
   -  Contar cu√°ntas vocales tiene.

--------------


