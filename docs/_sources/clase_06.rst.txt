.. _clase_06:

Clase 6: Programación Orientada a Objetos 
===========================================


Breve introducción a Programación Orientada a Objetos
-----------------------------------------------------

Vimos como escribir funciones que realizan un trabajo específico y nos
devuelven un resultado. La mayor parte de nuestros programas van a estar
diseñados con un hilo conductor principal, que utiliza una serie de
funciones para realizar el cálculo. De esta manera, el código es
altamente reusable.

Hay otras maneras de organizar el código, una de ellas es
particularmente útil cuando un conjunto de rutinas comparte un dado
conjunto de datos. En ese caso, puede ser adecuado utilizar un esquema
de programación orientada a objetos. En esta modalidad programamos
distintas entidades, donde cada una tiene un comportamiento, y
determinamos una manera de interactuar entre ellas.

Clases y Objetos
----------------

Una ``Clase`` define características que tienen los ``objetos`` de dicha
clase. En general la clase tiene: un nombre y características (campos o
atributos y métodos).

Un Objeto, en programación, puede pensarse como la representación de un
objeto real, de una dada clase. Un objeto real tiene una composición y
características, y además puede realizar un conjunto de actividades
(tiene un comportamiento). Cuando programamos, las “partes” son los
datos, y el “comportamiento” son los métodos.

Ejemplos de la vida diaria serían: Una clase *Bicicleta*, y muchos
objetos del tipo bicicleta (mi bicicleta, la suya, etc). La definición
de la clase debe contener la información de qué es una bicicleta (dos
ruedas, manubrio, etc) y luego se realizan muchas copias del tipo
bicicleta (los objetos).

Se dice que los **objetos** son instancias de una **clase**, por ejemplo
ya vimos los números enteros. Cuando definimos: ``a = 3`` estamos
diciendo que ``a`` es una instancia (objeto) de la clase ``int``.

Los objetos pueden guardar datos (en este caso ``a`` guarda el valor
``3``). Las variables que contienen los datos de los objetos se llaman
usualmente campos o atributos. Las acciones que tienen asociadas los
objetos se realizan a través de funciones internas, que se llaman
métodos.

Las clases se definen con la palabra reservada ``class``, veamos un
ejemplo simple:

.. code:: python

    class Punto:
      "Clase para describir un punto en el espacio"
    
      def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    


.. code:: python

    P1 = Punto(0.5, 0.5, 0)

.. code:: python

    P1




.. parsed-literal::

    <__main__.Punto at 0x7f7eb59560e0>



Vemos que ``P1`` es un objeto del tipo ``Punto`` que está alojado en una
dada dirección de memoria (dada por ese número largo hexadecimal). Para
referirnos a los *atributos* de ``P1`` se utiliza notación “de punto”:

.. code:: python

    P1.x, P1.z




.. parsed-literal::

    (0.5, 0)



Como vemos, acabamos de definir una clase de tipo Punto. A continuación
definimos un *método* ``__init__`` que hace el trabajo de inicializar el
objeto.

Algunos puntos a notar:

-  La línea ``P1 = Punto(0.5, 0.5, 0)`` crea un nuevo objeto del tipo
   ``Punto``. Notar que usamos paréntesis como cuando llamamos a una
   función pero Python sabe que estamos “llamando” a una clase y creando
   un objeto.

-  El método ``__init__`` es especial y es el Constructor de objetos de
   la clase. Es llamado automáticamente al definir un nuevo objeto de
   esa clase. Por esa razón, le pasamos los dos argumentos al crear el
   objeto.

-  El primer argumento del método, ``self``, debe estar presente en la
   definición de todos los métodos pero no lo pasamos como argumento
   cuando hacemos una llamada a la función. **Python** se encarga de
   pasarlo en forma automática. Lo único relevante de este argumento es
   que es el primero para todos los métodos, el nombre ``self`` puede
   cambiarse por cualquier otro **pero, por convención, no se hace**.

.. code:: python

    P2 = Punto()


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-5-b35d1ccc6ec0> in <module>
    ----> 1 P2 = Punto()
    

    TypeError: Punto.__init__() missing 3 required positional arguments: 'x', 'y', and 'z'


Por supuesto la creación del objeto falla si no le damos ningún
argumento porque los argumentos de ``__init__`` no son opcionales.
Modifiquemos eso y aprovechamos para definir algunos otros métodos que
pueden ser útiles:

.. code:: python

    from math import atan2
    
    class Punto:
      "Clase para describir un punto en el espacio"
    
      def __init__(self, x=0, y=0, z=0):
        "Inicializa un punto en el espacio"
        self.x = x
        self.y = y
        self.z = z
        return None
    
      def angulo_azimuthal(self):
        "Devuelve el ángulo que forma con el eje x, en radianes"
        return atan2(self.y, self.x)

.. code:: python

    P1 = Punto(0.5, 0.5)

.. code:: python

    P1.angulo_azimuthal()




.. parsed-literal::

    0.7853981633974483



.. code:: python

    P2 = Punto()

.. code:: python

    P2.x




.. parsed-literal::

    0



.. code:: python

    help(P1)


.. parsed-literal::

    Help on Punto in module __main__ object:
    
    class Punto(builtins.object)
     |  Punto(x=0, y=0, z=0)
     |  
     |  Clase para describir un punto en el espacio
     |  
     |  Methods defined here:
     |  
     |  __init__(self, x=0, y=0, z=0)
     |      Inicializa un punto en el espacio
     |  
     |  angulo_azimuthal(self)
     |      Devuelve el ángulo que forma con el eje x, en radianes
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    


El objeto ``P1`` es del tipo ``Punto`` y tiene definidos los métodos
``__init__()`` (el constructor) y el método ``angulo_azimuthal()`` que
programamos para obtener el ángulo. Además tiene el método ``__dict__``
que provee un diccionario con los datos del objeto:

.. code:: python

    P1.__dict__




.. parsed-literal::

    {'x': 0.5, 'y': 0.5, 'z': 0}



Cuando ejecutamos uno de los métodos de un objeto, es equivalente a
hacer la llamada al método de la clase, dando como primer argumento el
objeto en cuestión:

.. code:: python

    pp = Punto(0.1, "s", [1,2])

.. code:: python

    pp




.. parsed-literal::

    <__main__.Punto at 0x7f7eb59558d0>



.. code:: python

    pp.azimuthal()


::


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-15-da71cb3c85b2> in <module>
    ----> 1 pp.azimuthal()
    

    AttributeError: 'Punto' object has no attribute 'azimuthal'


.. code:: python

    print(P1.angulo_azimuthal())
    print(Punto.angulo_azimuthal(P1))


.. parsed-literal::

    0.7853981633974483
    0.7853981633974483


Al hacer la llamada a un método de una “instancia de la Clase” (o un
objeto), omitimos el argumento ``self``. El lenguaje traduce nuestro
llamado: ``P1.angulo_azimuthal()`` como ``Punto.angulo_azimuthal(P1)``
ya que ``self`` se refiere al objeto que llama al método.

Métodos especiales
~~~~~~~~~~~~~~~~~~

Volviendo a mirar la definición de la clase, vemos que ``__init__()`` es
un método “especial”. No necesitamos ejecutarlo explícitamente ya que
Python lo hace automáticamente al crear cada objeto de la clase dada. En
*Python* el usuario/programador tiene acceso a todos los métodos y
atributos. Por convención los nombres que inician con guión bajo se
presupone que no son para ser utilizados directamente. En particular,
los que están rodeados por dos guiones bajos tienen significado especial
y *Python* los va a utilizar en forma autómatica en distintas ocasiones.

Herencia
--------

Una de las características de la programación orientada a objetos es la
facilidad de reutilización de código. Uno de los mecanismos más
importantes es a través de la herencia. Cuando definimos una nueva
clase, podemos crearla a partir de un objeto que ya exista. Por ejemplo,
utilizando la clase ``Punto`` podemos definir una nueva clase para
describir un vector en el espacio:

.. code:: python

    class Vector(Punto):
      "Representa un vector en el espacio"
    
      def suma(self, v2):
        "Calcula un vector que contiene la suma de dos vectores"
        print("Aún no implementada la suma de dos vectores") 
        # código calculando v = suma de self + v2
        # ...
    
      def producto(self, v2):
        "Calcula el producto interno entre dos vectores"
        print("Aún no implementado el producto interno de dos vectores") 
        # código calculando el producto interno pr = v1 . v2
    
      def abs(self):
        "Devuelve la distancia del punto al origen"
        print("Aún no implementado la norma del vector") 
        # código calculando el producto interno pr = v1 . v2
    
        

Acá hemos definido un nuevo tipo de objeto, llamado ``Vector`` que se
deriva de la clase ``Punto``. Veamos cómo funciona:

.. code:: python

    v1 = Vector(2,3.1)
    v2 = Vector()

.. code:: python

    v1




.. parsed-literal::

    <__main__.Vector at 0x7f7eb5955060>



.. code:: python

    v1.x




.. parsed-literal::

    2



.. code:: python

    v1.angulo_azimuthal()




.. parsed-literal::

    0.9978301839061905



.. code:: python

    v1.x, v1.y, v1.z




.. parsed-literal::

    (2, 3.1, 0)



.. code:: python

    v2.x, v2.y, v2.z




.. parsed-literal::

    (0, 0, 0)



.. code:: python

    v = v1.suma(v2)


.. parsed-literal::

    Aún no implementada la suma de dos vectores


.. code:: python

    print(v)


.. parsed-literal::

    None


Volviendo a la definición de un objeto, vimos que ``__init__()`` es un
método “especial”. Otro método especial es ``__add__()`` que nos permite
definir la operación suma entre objetos:

.. code:: python

    class Vector(Punto):
      "Representa un vector en el espacio"
    
      def __add__(self, v2):
        "Calcula un vector que contiene la suma de dos vectores"
        print("Aún no implementada la suma de dos vectores") 
        # código calculando v = suma de self + v2
        # ...
    
      def producto(self, v2):
        "Calcula el producto interno entre dos vectores"
        print("Aún no implementado el producto interno de dos vectores") 
        # código calculando el producto interno pr = v1 . v2
    
      def abs(self):
        "Devuelve la distancia del punto al origen"
        print("Aún no implementado la norma del vector") 
        # código calculando el producto interno pr = v1 . v2
    
        

.. code:: python

    v1 = Vector(1,2,3)
    v2 = Vector(1,2,-3)

.. code:: python

    v1 + v2


.. parsed-literal::

    Aún no implementada la suma de dos vectores


Los métodos que habíamos definido para los puntos del espacio, son
accesibles para el nuevo objeto. Además podemos agregar (extender) el
nuevo objeto con otros atributos y métodos.

Como vemos, aún no está implementado el cálculo de las distintas
funciones, eso forma parte del siguiente …

--------------

Ejercicios 06 (a)
-----------------

1. Implemente los métodos ``__add__``, ``producto`` y ``abs``

   -  ``__add__()`` debe retornar un objeto del tipo ``Vector`` y
      contener en cada componente la suma de las componentes de los dos
      vectores que toma como argumento.

   -  ``producto`` toma como argumentos dos vectores y retorna un número
      real con el valor del producto interno

   -  ``abs`` toma como argumentos el propio objeto y retorna el número
      real correspondiente

   Su uso será el siguiente:

   .. code:: python

      v1 = Vector(1,2,3)
      v2 = Vector(3,2,1)
      v = v1 + v2
      pr = v1.producto(v2)
      a = v1.abs()

--------------


