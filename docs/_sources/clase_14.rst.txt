.. _clase_14:

Clase 14: Animaciones 
=======================


Animaciones con **Matploblib**
------------------------------

**Matplotlib** tiene funciones para hacer animaciones de una manera
conveniente. Hay excelente información sobre el tema en:

-  `La documentación (con
   ejemplos) <http://matplotlib.org/api/animation_api.html>`__
-  `Tutorial en Pythonic
   Perambulations <http://jakevdp.github.io/blog/2012/08/18/matplotlib-animation-tutorial/>`__

Vamos a ver brevemente cómo hacer animaciones, en pocos Pasos

Una animación simple en pocos pasos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    cd scripts/animaciones


.. parsed-literal::

    /home/fiol/Clases/IntPython/clases-python/clases/scripts/animaciones


.. code:: python

    %matplotlib tk
    %run ejemplo_animation_1.py

.. code:: python


   import numpy as np
   import matplotlib.pyplot as plt
   import matplotlib.animation as animation
   plt.ioff()
   # Creamos los datos
   xmax = 2*np.pi
   Npts= 50

   x = np.linspace(0, xmax, Npts)
   data = np.vstack([x, np.sin(x)])

   def update_line(num, data, line):
     line.set_data(data[:, :num])
     return line,

   # Creamos la figura e inicializamos
   # Graficamos una línea sin ningún punto
   # Fijamos las condiciones de graficación
   fig1, ax = plt.subplots(figsize=(12,8))
   L, = plt.plot([], [], '-o') # equivalente a la siguiente
   # L = plt.plot([],[] , '-o')[0]
   ax.set_xlim(0, xmax)
   ax.set_ylim(-1.1, 1.1)
   ax.set_xlabel('x')
   ax.set_title('Animación de una oscilación')


   # 
   line_ani = animation.FuncAnimation(fig1, update_line, Npts, fargs=(data, L), interval=100, blit=True)

   plt.show()

Este código da como resultado una función oscilante que se va creando.
Este es un ejemplo simple que puede ser útil para graficar datos de una
medición o de un cálculo más o menos largo.

.. image:: figuras/line.gif

Preparación general
^^^^^^^^^^^^^^^^^^^

Como vemos, después de importar el submódulo ``animation`` (además de lo
usual):

.. code:: python

   import numpy as np
   import matplotlib.pyplot as plt
   import matplotlib.animation as animation
   plt.ioff()

nos aseguramos que estamos trabajando en modo **no** interactivo (con
``plt.ioff()``).

Creamos los datos para graficar
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Creación de datos para graficar

Creamos los datos para mostrar en la animación.

.. code:: python

   xmax = 2*np.pi
   Npts = 50
   x = np.linspace(0, xmax, Npts)
   data = np.vstack([x, np.sin(x)])

Acá ``data`` es un array 2D, con los datos :math:`x`, :math:`y`.

Preparación de la figura
^^^^^^^^^^^^^^^^^^^^^^^^

A continuación preparamos la zona de graficación:

1. Creamos la figura y eje
2. Creamos las líneas de graficación (una en este caso)
3. Fijamos los límites de graficación
4. Agregamos el texto, que va a ser invariante durante la animación

.. code:: python

   fig1, ax = plt.subplots(figsize=(12,8))
   L, = plt.plot([0], [0], '-o', lw=3)
   ax.set_xlim(0, xmax)
   ax.set_ylim(-1.1, 1.1)
   ax.set_xlabel('x')
   ax.set_title('Animación de una oscilación')

Como sabemos, el llamado a ``plot()`` devuelve una lista de líneas (de
un solo elemento). A este elemento lo llamamos ``L``, y ya le damos las
características que queremos que tenga. En este caso, fijamos el símbolo
(círculos), con líneas de ancho 3. Vamos a modificar esta línea ``L`` en
cada cuadro de la animación.

Función para actualizar la línea
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Debemos crear una función que modifique las curvas en cada cuadro.

.. code:: python

   def update_line(num, data, line):
     line.set_data(data[:, :num])
     return line,

Esta función debe recibir como argumento el número de cuadro, que acá
llamamos ``num``. Además, en este caso recibe los datos a graficar, y la
línea a modificar.

Esta función devuelve una línea ``L``, que es la parte del gráfico que
queremos que se actualice en cada frame.

Notemos acá que no es necesario que tome como argumento los datos
guardados en ``data`` y la línea ``line``, ya que son variables globales
a las que hay acceso dentro del *script*. De la misma manera no es
necesario que devuelva la línea, por la misma razón.

Animación de la figura
^^^^^^^^^^^^^^^^^^^^^^

Finalmente llamamos a la función que hace la animación:
``animation.FuncAnimation()``

.. code:: python

    import matplotlib.animation as animation
    np.info(animation.FuncAnimation)


.. parsed-literal::

     FuncAnimation(fig, func, frames=None, init_func=None, fargs=None,
                   save_count=None, *, cache_frame_data=True, **kwargs)
    
    Makes an animation by repeatedly calling a function *func*.
    
    .. note::
    
        You must store the created Animation in a variable that lives as long
        as the animation should run. Otherwise, the Animation object will be
        garbage-collected and the animation stops.
    
    Parameters
    ----------
    fig : `~matplotlib.figure.Figure`
        The figure object used to get needed events, such as draw or resize.
    
    func : callable
        The function to call at each frame.  The first argument will
        be the next value in *frames*.   Any additional positional
        arguments can be supplied via the *fargs* parameter.
    
        The required signature is::
    
            def func(frame, *fargs) -> iterable_of_artists
    
        If ``blit == True``, *func* must return an iterable of all artists
        that were modified or created. This information is used by the blitting
        algorithm to determine which parts of the figure have to be updated.
        The return value is unused if ``blit == False`` and may be omitted in
        that case.
    
    frames : iterable, int, generator function, or None, optional
        Source of data to pass *func* and each frame of the animation
    
        - If an iterable, then simply use the values provided.  If the
          iterable has a length, it will override the *save_count* kwarg.
    
        - If an integer, then equivalent to passing ``range(frames)``
    
        - If a generator function, then must have the signature::
    
             def gen_function() -> obj
    
        - If *None*, then equivalent to passing ``itertools.count``.
    
        In all of these cases, the values in *frames* is simply passed through
        to the user-supplied *func* and thus can be of any type.
    
    init_func : callable, optional
        A function used to draw a clear frame. If not given, the results of
        drawing from the first item in the frames sequence will be used. This
        function will be called once before the first frame.
    
        The required signature is::
    
            def init_func() -> iterable_of_artists
    
        If ``blit == True``, *init_func* must return an iterable of artists
        to be re-drawn. This information is used by the blitting algorithm to
        determine which parts of the figure have to be updated.  The return
        value is unused if ``blit == False`` and may be omitted in that case.
    
    fargs : tuple or None, optional
        Additional arguments to pass to each call to *func*.
    
    save_count : int, default: 100
        Fallback for the number of values from *frames* to cache. This is
        only used if the number of frames cannot be inferred from *frames*,
        i.e. when it's an iterator without length or a generator.
    
    interval : int, default: 200
        Delay between frames in milliseconds.
    
    repeat_delay : int, default: 0
        The delay in milliseconds between consecutive animation runs, if
        *repeat* is True.
    
    repeat : bool, default: True
        Whether the animation repeats when the sequence of frames is completed.
    
    blit : bool, default: False
        Whether blitting is used to optimize drawing.  Note: when using
        blitting, any animated artists will be drawn according to their zorder;
        however, they will be drawn on top of any previous artists, regardless
        of their zorder.
    
    cache_frame_data : bool, default: True
        Whether frame data is cached.  Disabling cache might be helpful when
        frames contain large objects.
    
    
    Methods:
    
      new_frame_seq  --  Return a new sequence of frame information.
      new_saved_frame_seq  --  Return a new sequence of saved/cached frame information.
      pause  --  Pause the animation.
      resume  --  Resume the animation.
      save  --  Save the animation as a movie file by drawing every frame.
      to_html5_video  --  Convert the animation to an HTML5 ``<video>`` tag.
      to_jshtml  --  Generate HTML representation of the animation.


.. code:: python

   line_anim = animation.FuncAnimation(fig1, update_line, Npts, 
                      fargs=(data, L), interval=100, blit=True)

La función ``FuncAnimation()`` toma como argumentos:

-  la figura (``fig1``) donde se realiza el gráfico.

-  Una función a la que llama antes de dibujar cada *frame*
   (``update_line``),

-  El argumento ``interval`` da el tiempo entre cuadros, en
   milisegundos.

-  El argumento ``fargs`` es una tuple con los argumentos que necesita
   la función ``update_line()``. En este caso ``(data, L)``.

-  El argumento ``blit=True`` hace que sólo se actualicen las partes que
   cambian en la animación, mientras que las partes estáticas no se
   dibujan en cada cuadro.

Es importante que el objeto creado por ``FuncAnimation()`` no se
destruya. Esto lo podemos asegurar asignando el objeto resultante a una
variable, en este caso line_anim.

Opcional: grabar la animación a un archivo
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Podemos grabar la animación a un archivo usando el método ``save()`` o
el método ``to_html5_video()`` del objeto (``anim``) que devuelve la
función ``FuncAnimation()``.

Para poder grabar a archivo las animaciones se necesita tener instalados
programas externos (alguno de *ffmpeg*, *avconv*, *imagemagick*). Ver
https://matplotlib.org/api/animation_api.html para más información.

Segundo ejemplo simple: Quiver
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Para hacer una animación de un campo de fuerzas o velocidades
necesitamos datos en tres dimensiones. El siguiente ejemplo sigue los
pasos de la animación anterior, excepto en la creación de datos y la
graficación, que en lugar de usar ``plot()`` usa ``quiver()``:

.. code:: python


   import numpy as np
   import matplotlib.pyplot as plt
   import matplotlib.animation as animation
   plt.style.use('ggplot')

   plt.ioff()

   # ############################################################
   # Creación de datos
   x = np.linspace(-3, 3, 91)
   t = np.linspace(0, 25, 30)
   y = np.linspace(-3, 3, 91)
   X3, Y3, T3 = np.meshgrid(x, y, t)
   sinT3 = np.sin(2*np.pi*T3 /
                  T3.max(axis=2)[..., np.newaxis])

   G = (X3**2 + Y3**2)*sinT3
   # Graficar una flecha cada step puntos
   step = 10
   x_q, y_q = x[::step], y[::step]
    
   # Create U and V vectors to plot
   U = G[::step, ::step, :-1].copy()
   V = np.roll(U, shift=3, axis=2)

   # ############################################################
   # Figura y ejes. 
   fig1, ax = plt.subplots(figsize=(12,8))

   ax.set_aspect('equal')
    
   ax.set(xlim=(-4, 4), ylim=(-4, 4))

    
   qax = ax.quiver(x_q, y_q, U[..., 0], V[..., 0],
                   scale=100)
    
   def animate(i):
     qax.set_UVC(U[..., i], V[..., i])

   anim = animation.FuncAnimation(fig1, animate, interval=100, frames=len(t)-1, repeat=True)

   # anim.save('quiver.gif', writer='imagemagick')
   anim.save('quiver.mp4')
   plt.show()

.. code:: python

    %run ejemplo_quiver.py

Comentarios:
^^^^^^^^^^^^

-  Se utilizó la función ``quiver()`` para generar un campo vectorial.
   La forma de esta función es:

   quiver([X, Y], U, V, [C], \**kw)

   *X*, *Y* define the arrow locations, *U*, *V* define the arrow
   directions, and *C* optionally sets the color.

-  Se utilizaron *Ellipsis*, por ejemplo en casos como:

   .. code:: python

      U[..., 0]

   Las elipsis (tres puntos o la palabra ``Ellipsis``) indican todo el
   rango para todas las dimensiones que no se dan explícitamente. En
   este ejemplo el *array* ``U`` tiene tres dimensiones, por lo que
   tendremos:

   .. code:: python

      U[..., 0] = U[:, :, 0]

   En general, las elipses reemplazan a los dos puntos en todas las
   dimensiones no dadas explícitamente

.. code:: python

    a = np.arange(36)
    a2 = a.reshape((6,-1))
    a4 = a.reshape((2,3,2,3))


.. code:: python

    print(a2[:,0])
    print(a2[..., 0])


.. parsed-literal::

    [ 0  6 12 18 24 30]
    [ 0  6 12 18 24 30]


.. code:: python

    print(a4[0,:,:,0])
    print(a4[0,...,0])


.. parsed-literal::

    [[ 0  3]
     [ 6  9]
     [12 15]]
    [[ 0  3]
     [ 6  9]
     [12 15]]


.. code:: python

    (a4[...,0] == a4[:,:,:,0]).all()




.. parsed-literal::

    True



-  Uso de ``np.roll(a, shift, axis=None)`` que mueve elementos una
   distancia ``shift`` a lo largo del eje ``axis``, y cuando pasan la
   última posición los reintroduce al principio. Por ejemplo, en una
   dimensión:

.. code:: python

    x = np.arange(10)
    print(x)
    print(np.roll(x, 2))


.. parsed-literal::

    [0 1 2 3 4 5 6 7 8 9]
    [8 9 0 1 2 3 4 5 6 7]


Tercer ejemplo
~~~~~~~~~~~~~~

Veamos un ejemplo similar al primero, pero donde vamos cambiando los
límites de los ejes en forma manual, a medida que los datos lo requieren

.. code:: python

   import numpy as np
   import matplotlib.pyplot as plt
   import matplotlib.animation as animation

   # Calcula los datos en tiempo real. 
   def data_gen(t=0):
     cnt = 0
     while cnt < 1000:
       cnt += 1
       t += 0.1
       yield t, np.sin(2 * np.pi * t) * np.exp(-t / 10.)


   # Necesitamos que se puede acceder a estas variables
   # desde varias funciones -> globales
   fig, ax = plt.subplots()
   line, = ax.plot([], [], lw=2)
   xdata, ydata = [], []

   def init():
     ax.grid()
     ax.set_ylim(-1.1, 1.1)
     ax.set_xlim(0, 10)
     del xdata[:]
     del ydata[:]
     line.set_data(xdata, ydata)
     return line,


   def run(data):
     # update the data
     t, y = data
     xdata.append(t)
     ydata.append(y)
     xmin, xmax = ax.get_xlim()

     # Si los datos salen del eje, agrandamos el eje
     # Después tenemos que redibujar el canvas manualmente
     if t >= xmax:
       ax.set_xlim(xmin, 2 * xmax)
       ax.figure.canvas.draw()
     line.set_data(xdata, ydata)

     return line,

   ani = animation.FuncAnimation(fig, run, data_gen, blit=False,
                                 interval=30,repeat=False, init_func=init)

   plt.show()

.. code:: python

    %run animate_decay.py

.. code:: python

    plt.style.reload_library()
    plt.style.use('default')

--------------

Ejercicios 14 (a)
-----------------

1. Utilizando **Matplotlib**:

   -  Hacer un gráfico donde dibuje una parábola :math:`y = x^{2}` en el
      rango :math:`[-5,5]`.
   -  En el mismo gráfico, agregar un círculo en :math:`x=-5`.
   -  El círculo debe moverse siguiendo la curva, como se muestra en la
      figura

   .. image:: figuras/pelota.gif

2. **PARA ENTREGAR. Caída libre 2:** Modificar el ejercicio de la clase
   8 de caída libre que entregó, para aceptar dos nuevas opciones:

   -  La opción ``--vx`` permite dar una velocidad inicial en la
      dirección horizontal.
   -  La opción ``--animate``, tal que cuando se utilice, el programa
      muestre una animación de la trayectoria.
   -  La animación tiene que tener un cartel indicando el tiempo, y la
      velocidad y altura correspondiente a ese tiempo.
   -  Agregue una “cola fantasma” a la partícula, que muestre posiciones
      anteriores.

   Envíe el programa llamado **14_Suapellido.py** en un adjunto por
   correo electrónico, con asunto: **14_Suapellido**

--------------

.


