.. _clase_15:

Clase 15: Interfaces con otros lenguajes: Fortran
==================================================


Ejemplo 1: Rotación de vectores
-------------------------------

Supongamos que queremos resolver el problema de la rotación de vectores
en el espacio usando los `tres ángulos de
Euler <https://mathworld.wolfram.com/EulerAngles.html>`__.

Dado un array con los tres ángulos de Euler, calculamos la matriz de
rotación (de 3 x 3), y la aplicamos (esto es, multiplicamos) a un
arreglo de *N* vectores.

En una primer versión, podemos hacerlo en Python directamente en el
notebook:

.. code:: python

    import numpy as np
    
    def matrix_rotation(angles):
      cx, cy, cz = np.cos(angles)
      sx, sy, sz = np.sin(angles)
      R = np.zeros((3, 3))
      R[0, 0] = cx * cz - sx * cy * sz
      R[0, 1] = cx * sz + sx * cy * cz
      R[0, 2] = sx * sy
    
      R[1, 0] = -sx * cz - cx * cy * sz
      R[1, 1] = -sx * sz + cx * cy * cz
      R[1, 2] = cx * sy
    
      R[2, 0] = sy * sz
      R[2, 1] = -sy * cz
      R[2, 2] = cy
      return R
    
    
    def rotate(angles, v):
      return np.dot(matrix_rotation(angles), v)

.. code:: python

    N = 100
    # Ángulos de Euler
    angle = np.random.random(3)
    # Definimos N vectores tridimensionales
    v = np.random.random((3, N))

Si ya tenemos un módulo donde están programadas las funciones necesarias

.. code:: python

    # %load rotacion_p.py
    #! /usr/bin/ipython3
    import numpy as np
    
    
    def matrix_rotation(angles):
      cx, cy, cz = np.cos(angles)
      sx, sy, sz = np.sin(angles)
      R = np.zeros((3, 3))
      R[0, 0] = cx * cz - sx * cy * sz
      R[0, 1] = cx * sz + sx * cy * cz
      R[0, 2] = sx * sy
    
      R[1, 0] = -sx * cz - cx * cy * sz
      R[1, 1] = -sx * sz + cx * cy * cz
      R[1, 2] = cx * sy
    
      R[2, 0] = sy * sz
      R[2, 1] = -sy * cz
      R[2, 2] = cy
      return R
    
    
    def rotate(angles, v):
      return np.dot(matrix_rotation(angles), v)


es fácil utilizarlas:

.. code:: python

    N = 100
    # Ángulos de Euler
    angle = np.random.random(3)
    # Definimos N vectores tridimensionales
    v = np.random.random((3, N))

.. code:: python

    y = rotate(angle,v)

.. code:: python

    print(angle)
    print(y[:,0:5].T)

Importando desde un módulo en un archivo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

También podemos tener las funciones para la rotación en un módulo
``rotaciones.py``. Recordemos cómo se importarían en este caso

.. code:: python

    pwd

.. code:: python

    cd ../scripts/interfacing_python

.. code:: python

    ls

.. code:: python

    import rotaciones as rotp

.. code:: python

    help(rotp)

.. code:: python

    yp = rotp.rotate(angle,v)

.. code:: python

    print(yp[:,0:5].T)
    np.allclose(y,yp)

Interfaces con Fortran
----------------------

Veamos cómo trabajar si tenemos el código para realizar las rotaciones
en Fortran

Primer ejemplo: Nuestro código
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

El código en Fortran que tenemos es:

.. code:: fortran

   function rotate(theta, v, N) result(y)
     implicit none
     integer :: N
     real(8), dimension(3), intent(IN) :: theta
     real(8), dimension(3,N), intent(IN) :: v
     real(8), dimension(3,N) :: y
     real(8), dimension(3,3) :: R
     real(8) :: cx, cy, cz, sx, sy, sz

     ! Senos y Cosenos de los tres ángulos de Euler 
     cx = cos(theta(1)); cy = cos(theta(2)); cz = cos(theta(3))
     sx = sin(theta(1)); sy = sin(theta(2)); sz = sin(theta(3))

     ! Matriz de rotación
     R(1,1) = cx*cz - sx*cy*sz
     R(1,2) = cx*sz + sx*cy*cz
     R(1,3) = sx*sy

     R(2,1) = -sx*cz - cx*cy*sz
     R(2,2) = -sx*sz + cx*cy*cz
     R(2,3) = cx*sy

     R(3,1) = sy*sz
     R(3,2) = -sy*cz
     R(3,3) = cy

     ! Aplicamos la rotación
     y = matmul(R, v)
   end function rotate

.. code:: python

    cd ../interfacing_F

F2PY
~~~~

F2PY -Fortran to Python interface generator- es una utilidad que permite
generar una interface para utilizar funciones y datos definidos en
Fortran desde Python.

Información sobre la interfaz entre Fotran y Python, y en particular
sobre F2PY, puede encontrarse en:

-  `Scipy
   cookbook <http://scipy-cookbook.readthedocs.io/items/idx_interfacing_with_other_languages.html>`__
-  `F2PY Users Guide and Reference
   Manual <https://docs.scipy.org/doc/numpy-dev/f2py/index.html>`__
-  `Fortran Best
   Practices <http://www.fortran90.org/src/best-practices.html#interfacing-with-python>`__
-  http://websrv.cs.umt.edu/isis/index.php/F2py_example

El primer paso es utilizar esta utilidad:

.. code:: bash

   $ f2py3 -c rotacion.f90 -m rotacion_f

.. code:: python

    !f2py3 -c rotacion.f90 -m rotacion_f

.. code:: python

    from rotacion_f import rotaciones as rotf

.. code:: python

    yf = rotf.rotate(angle, v)
    print(y[:,0:5].T)
    print(yf[:,0:5].T)
    np.allclose(yf,y)

Veamos qué es exactamente lo que importamos:

.. code:: python

    np.info(rotf.rotate)

Como vemos, estamos usando la función ``rotate`` definida en Fortran.
Notar que: \* Tiene tres argumentos. \* Dos argumentos requeridos:
``angles`` y ``v`` \* Un argumento, correspondiente a la dimensión ``n``
que F2PY automáticamente detecta como opcional.

Segundo Ejemplo: Código heredado
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

La conversión que realizamos con f2py3 la podríamos haber realizado en
dos pasos:

.. code:: bash

   $ f2py3 rotacion.f90 -m rotacion_f -h rotacion.pyf
   $ f2py3 -c rotacion.pyf -m rotacion_f

En el primer paso se crea un archivo *signature* que después se utiliza
para crear el módulo que llamaremos desde **Python**. Haciéndolo en dos
pasos nos permite modificar el texto del archivo *.pyf* antes de
ejecutar el segundo comando.

Esto es útil cuando el código original no es lo suficientemente
“moderno”, no tiene toda la información necesaria sobre los argumentos o
es un código que uno no quiere o puede editar. Veamos que forma tienen
con un ejemplo más simple (tomado de la `guía de
usuario <https://docs.scipy.org/doc/numpy-dev/f2py/getting-started.html>`__):

.. code:: fortran

         SUBROUTINE FIB(A,N)
   C
   C     CALCULATE FIRST N FIBONACCI NUMBERS
   C
         INTEGER N
         REAL*8 A(N)
         DO I=1,N
            IF (I.EQ.1) THEN
               A(I) = 0.0D0
            ELSEIF (I.EQ.2) THEN
               A(I) = 1.0D0
            ELSE 
               A(I) = A(I-1) + A(I-2)
            ENDIF
         ENDDO
         END

.. code:: python

    !f2py3 --overwrite-signature fib1.f -m fib1 -h fib1.pyf

.. code:: python

    !cat fib1.pyf

El contenido del archivo ``fib1.pyf`` es:

.. code:: fortran90

   python module fib1 ! in 
       interface  ! in :fib1
           subroutine fib(a,n) ! in :fib1:fib1.f
               real*8 dimension(n) :: a
               integer, optional,check(len(a)>=n),depend(a) :: n=len(a)
           end subroutine fib
       end interface 
   end python module fib1

Este código indica que tenemos una subrutina que toma dos argumentos: -
``a`` es un array - ``n`` es un entero opcional, que tiene que ser mayor
que ``len(a)``

.. code:: python

    !f2py3  -c fib1.pyf fib1.f 

.. code:: python

    ls

.. code:: python

    import fib1

.. code:: python

    print(fib1.fib.__doc__)

.. code:: python

    a = np.zeros(12)
    fib1.fib(a)
    print(a)

.. code:: python

    a = np.zeros(12)
    fib1.fib(a,8)
    print(a)

.. code:: python

    a = np.zeros(12)
    fib1.fib(a,18)
    print(a)

Esta es una de las características de F2PY: hace un chequeo básico de
los argumentos. Hay otro error que no llega a atrapar: Si le pasamos un
array que no es del tipo indicado, falla (sin avisar). Éste claramente
no es el comportamiento deseado:

.. code:: python

    a = np.zeros(12, dtype=int)
    fib1.fib(a)
    print(a)

Vamos a modificar el archivo de *signature* para enseñarle dos cosas:

-  El entero es un argumento de entrada (requerido)
-  El *array* ``a`` es un archivo de salida **exclusivamente**. Entonces
   no debemos dárselo. La parte ``dimension(n)`` y ``depend(n)`` indica
   que debe crear un vector de ese tamaño.

.. code:: python

    !cat fib1.pyf 

.. code:: python

    !cat fib2.pyf

.. code:: python

    !f2py3  -c fib2.pyf fib1.f > /dev/null

.. code:: python

    import fib2
    print(fib2.fib.__doc__)

.. code:: python

    fib2.fib(9)

.. code:: python

    print(fib2.fib(14))

La segunda manera de arreglar este problema, en lugar de modificar el
archivo de *signature* podría haber sido modificar el código (o hacer
una rutina intermedia). Agregando comentarios de la forma ``Cf2py`` no
influimos en la compilación ``Fortran`` pero F2PY los reconoce. En este
caso le damos la información sobre la intención de los argumentos en el
código:

.. code:: fortran

         SUBROUTINE FIB(A,N)
   C
   C     CALCULATE FIRST N FIBONACCI NUMBERS
   C
         INTEGER N
         REAL*8 A(N)
   Cf2py intent(in) n
   Cf2py intent(out) a
   Cf2py depend(n) a
         DO I=1,N
            IF (I.EQ.1) THEN
               A(I) = 0.0D0
            ELSEIF (I.EQ.2) THEN
               A(I) = 1.0D0
            ELSE 
               A(I) = A(I-1) + A(I-2)
            ENDIF
         ENDDO
         END

.. code:: python

    !f2py3  -c fib3.f -m fib3 > /dev/null

.. code:: python

    import fib3
    print(fib3.fib.__doc__)

.. code:: python

    print(fib2.fib.__doc__)

como vemos, son exactamente iguales.

F2PY para código en C
~~~~~~~~~~~~~~~~~~~~~

Es posible usar F2PY para código escrito en C, pero en ese caso debemos
escribir el *signature file* a mano.

Para código en C es conveniente utilizar **Cython**. Cython es un
lenguaje de programación pensado para hacer más fácil escribir
extensiones a Python en C. Uno escribe el código en Cython, y luego es
traducido a C, con optimizaciones.

**Cython** también puede utilizarse con Fortran de una manera similar a
cómo se usa con C. Para más información ver la `documentación
oficial <http://docs.cython.org/en/latest/index.html>`__


Interfaces con otros lenguajes: C
---------------------------------

Existen varias formas de utilizar bibliotecas o códigos hechos en C
desde Python. Nosotros veremos el uso de ``Ctypes``, sin embargo existen
otras alternativas como `Cython <https://cython.org/>`__,
`CFFI <https://cffi.readthedocs.io/en/latest/>`__,
`pybind11 <https://pybind11.readthedocs.io/en/stable/>`__ y
`Boost.Python <https://www.boost.org/doc/libs/1_70_0/libs/python/doc/html/index.html>`__.

Seguimos con el ejemplo de la rotación de vectores. Por completitud,
agregamos la funciones en Python para comparar

.. code:: python

    import numpy as np

.. code:: python

    pwd

Si ya tenemos un módulo donde están programadas las funciones necesarias

.. code:: python

    import numpy as np
    
    def matrix_rotation(angles):
      cx, cy, cz = np.cos(angles)
      sx, sy, sz = np.sin(angles)
      R = np.zeros((3, 3))
      R[0, 0] = cx * cz - sx * cy * sz
      R[0, 1] = cx * sz + sx * cy * cz
      R[0, 2] = sx * sy
    
      R[1, 0] = -sx * cz - cx * cy * sz
      R[1, 1] = -sx * sz + cx * cy * cz
      R[1, 2] = cx * sy
    
      R[2, 0] = sy * sz
      R[2, 1] = -sy * cz
      R[2, 2] = cy
      return R
    
    
    def rotate(angles, v):
      return np.dot(matrix_rotation(angles), v)


.. code:: python

    N = 100
    # Ángulos de Euler
    angle = np.random.random(3)
    # Definimos N vectores tridimensionales
    v = np.random.random((3, N))

.. code:: python

    # y= rotp.rotate(angle, v)
    y = rotate(angle,v)

.. code:: python

    print(angle)
    print(y[:,0:5].T)

Veamos cómo trabajar si tenemos el código para realizar las rotaciones
en C.

Primer ejemplo: Nuestro código
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

El código en C que tenemos es:

.. code:: c

    typedef struct {
         float m[3][3];
       } m3x3;

       typedef struct {
         float a[3];
       } v3;
       
   ...

   float * rotate(float angles[3], float *v, int N){

           m3x3 R = matrix_rotation(angles);
           
           float* y = (float*)malloc(3*N*sizeof(float));
           v3 p;

           printf("%p\n",y);
           for(int i=0; i<N; i++){
               // p = &y[i*3];
               p = matmul3(R,&v[i*3]);
               y[i*3+0] = p.a[0];
               y[i*3+1] = p.a[1];
               y[i*3+2] = p.a[2];
               // printf("%6.3f %6.3f %6.3f \n",y[i*3+0],y[i*3+1],y[i*3+2]);
           }
           return y;


     }

.. code:: python

    cd ../scripts/interfacing_C

CTypes
~~~~~~

No vamos a usar directamente ``Ctypes``, sino a través de ``NumPy``, que
provee algunas funciones convenientes para acceder al código C.

El primer paso es compilar nuestro código y generar una biblioteca:

.. code:: bash

   $ gcc -fpic -Wall -shared rotacion.c -o librotacion.so

Si uno trabaja en Windows con `MS
C++ <https://visualstudio.microsoft.com/es/vs/features/cplusplus/>`__,
generará una dll

.. code:: cmd

   cl.exe -c rotacion.c
   link.exe /DLL /OUT:rotacion.dll

Si en cambio `instaló gcc <https://www.msys2.org/>`__, puede usar el
comando previo.

.. code:: python

    !gcc -fpic -Wall -shared rotacion.c -o librotacion.so

.. code:: python

    !ls

En segundo lugar, importamos el módulo ``ctypeslib``

.. code:: python

    import numpy.ctypeslib as ctl

Este módulo nos provee de la función ``load_library`` para importar la
biblioteca

.. code:: python

    help(ctl.load_library)

.. code:: python

    rotc = ctl.load_library('librotacion.so','.')

Una vez cargada la biblioteca, tenemos que definir adecuadamente cómo
pasar los argumentos a la función ``rotate`` de C:

.. code:: c

       float * rotate(float angles[3], float *v, int N)

Para eso se utiliza la función ``argtypes`` que recibe una lista de
tipos. Notemos que los dos primeros argumentos son arreglos de C (o sea,
punteros), mientras que el último es un entero.

.. code:: python

    npflags = ['C_CONTIGUOUS']   # Require a C contiguous array in memory
    
    float_1d_type = ctl.ndpointer(dtype=np.float32, ndim=1, flags=npflags) # Puntero a float, 1D
    float_2d_type = ctl.ndpointer(dtype=np.float32, ndim=2, flags=npflags) # Puntero a float, 2D

.. code:: python

    type(float_1d_type)

Con estos tipos de datos, defino los tipos de argumentos, que son tres
en total. El último es un dato de tipo entero, para lo cual se usa
directamente ``c_intp``. Para definir el tipo de argumentos de entrada a
la función ``rotc.rotate`` usamos el método ``argtypes``:

.. code:: python

    rotc.rotate.argtypes =  [float_1d_type, float_2d_type, ctl.c_intp]

Hagamos un ejemplo sencillo con N=2

.. code:: python

    N = 2
    # Ángulos de Euler
    angle = np.random.random(3).astype(np.float32)
    # Definimos N vectores tridimensionales
    v = np.random.random((3, N)).astype(np.float32)

Las funciones que dispongo en C reciben tipos ``float``, es decir que me
tengo que asegurar esto a través del método ``astype``.

Ahora tenemos que definir el tipo de dato de salida, que retorna C a
través de un puntero a float, ``float*``. Para esto usamos el método
``restype``. Como a priori no sé qué tipo de rango tiene mi arreglo de
salida, tengo que definirlo explícitamente.

.. code:: python

    rotc.rotate.restype = ctl.ndpointer(dtype=np.float32, shape=(N,3)) 

Hay que tener precaución con el manejo de arreglos, que es muy distinto
en C y Python. En Python son objetos, de los cuales yo puedo tener
distintas vistas, slices, etc. Hay que recordar que en principio estas
son formas de acceder al mismo objeto, pero no se pueden traducir
directamente a C, que necesita un arreglo contiguo de datos.

.. code:: python

    v = np.array([[1,0], [0,1], [0,0]]).astype(np.float32) 
    vt = v.T.copy()
    
    print(v)
    print(vt)
    print(np.shape(v))
    print(np.shape(v.T))

Veamos, v es un arreglo de 3 filas y 2 columnas, que contiene *dos*
vectores de tres dimensiones que se desean rotar, organizados como
columnas. Esto *no* es lo que necesita mi arreglo en C, que es tiene los
vectores organizados contiguamente en un solo arreglo unidimensional.
Entonces, tengo que transformarlo. Para eso usamos el ``.T``. Ojo que
además, hay que crear un objeto nuevo con ``copy()``, sino es una vista
del mismo objeto ``v``.

.. code:: python

    angle90 = np.array([0,0,np.pi/2],dtype = np.float32)
    print(angle90)

.. code:: python

    yf = rotc.rotate(angle90,
                          vt,
                          N) 
    y = rotate(angle90,v)

.. code:: python

    np.set_printoptions(suppress=True) # suppress controla cómo print va a escribir los números de punto flotante.
    
    print(y)
    print(yf.T)
    np.allclose(y,yf.T)
Interfaces con clases en C++
----------------------------

El ejemplo original está
`acá <https://stackoverflow.com/questions/602580/how-can-i-use-c-class-in-python>`__
que sigue `este
ejemplo <https://www.auctoris.co.uk/2017/04/29/calling-c-classes-from-python-with-ctypes/>`__:

El código en C++ que tenemos es:

.. code:: cpp

   class Test{
        private:
           int n;
        public:
           Test(int k){
               n=k;
           }
           void setInt(int k){
               n = k;
           }
           int getInt(){
               return n;
           }
   };

.. code:: python

    cd ../scripts/interfacing_Cpp

La implementación de Python que estamos usando está escrita en C, de
modo tal que tenemos que exportar las funciones de la clase ``Test`` en
C++ en el código fuente de la siguiente manera:

.. code:: cpp

   extern "C" 
   {
       // include below each method you want to make visible outside
       Test* init(int k) {return new Test(k);}
       void setInt(Test *self, int k) {self->setInt(k);}
       int getInt(Test *self) {return self->getInt();}
       
       // Add the declaration '__declspec(dllexport)' before each function in Windows
   }

La declaración ``extern "C"`` indican al compilador de C++ que genere
código compatible con C de todas las funciones incluídas en el bloque.

CTypes
~~~~~~

Vamos ahora a usar directamente ``Ctypes``. Como antes, el primer paso
es compilar nuestro código y generar una biblioteca:

.. code:: bash

   $ g++ -fpic -shared test.cpp -o libtest.so

Si uno trabaja en Windows, generará una dll

.. code:: cmd

   cl.exe -c test.cpp
   link.exe /DLL /OUT:test.dll

.. code:: python

    # !gcc -fpic -Wall -shared rotacion.c -o librotacion.so
    !g++ -fpic -shared test.cpp -o libtest.so
    


.. code:: python

    !ls

En segundo lugar, importamos el módulo ``ctypes``

.. code:: python

    import ctypes

Este módulo nos provee de la función ``CDLL`` para importar la
biblioteca

.. code:: python

    lib = ctypes.CDLL('./libtest.so')

Ahora vamos a crear una clase en Python equivalente a la que teníamos en
C++. Al igual que en el caso de C, tenemos que establecer los tipos de
datos de entrada (via el método ``argtypes``) y salida (vía el método
``restype``) para *cada función de la clase*.

.. code:: python

    
    class Test():
        def __init__(self, val: int):
            # Declare input and output types for each method you intend to use
            lib.init.argtypes = [ctypes.c_int]
            lib.init.restype = ctypes.c_void_p
    
            lib.setInt.argtypes = [ctypes.c_void_p, ctypes.c_int]
            lib.setInt.restype = ctypes.c_void_p
    
            lib.getInt.argtypes = [ctypes.c_void_p]
            lib.getInt.restype = ctypes.c_int
            
            # use the C++ constructor to build the instance 
            self.q = lib.init(val)
    
        def setInt(self, n):
            lib.setInt(self.q, n)
        
        def getInt(self):
            return lib.getInt(self.q)


.. code:: python

    T1 = Test(12)
    print(T1.getInt())
    T1.setInt(32)
    print(T1.getInt())

.. code:: python

    type(T1.q)
